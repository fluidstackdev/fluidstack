### This file was autogenerated by Nexus 0.11.3
### Do not make changes to this file directly


type AggregateBrand {
  count: Int!
}

type AggregateCollection {
  count: Int!
}

type AggregateOption {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type Attribute {
  id: ID!
  key: String!
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]
  value: String!
}

type AttributePayload {
  name: String!
  values: [AttributeValue!]!
}

type AttributeValue {
  id: ID!
  value: String!
}

input AttributeWhereInput {
  AND: [AttributeWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [AttributeWhereInput!]
  OR: [AttributeWhereInput!]
  products_every: ProductWhereInput
  products_none: ProductWhereInput
  products_some: ProductWhereInput
  value: String
  value_contains: String
  value_ends_with: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_ends_with: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_starts_with: String
}

type Brand {
  id: ID!
  name: String!
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]
}

type BrandConnection {
  aggregate: AggregateBrand!
  edges: [BrandEdge!]!
  pageInfo: PageInfo!
}

type BrandEdge {
  cursor: String!
  node: Brand!
}

enum BrandOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input BrandWhereInput {
  AND: [BrandWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [BrandWhereInput!]
  OR: [BrandWhereInput!]
  products_every: ProductWhereInput
  products_none: ProductWhereInput
  products_some: ProductWhereInput
}

type Collection {
  attributes: [AttributePayload!]!
  brands: [Brand!]!
  id: ID!
  name: String!
  options: [Option!]!
  products(attributesIds: [ID!], brandsIds: [ID!], first: Int, last: Int, optionsValuesIds: [ID!]): ProductConnection!
}

type CollectionConnection {
  aggregate: AggregateCollection!
  edges: [CollectionEdge!]!
  pageInfo: PageInfo!
}

type CollectionEdge {
  cursor: String!
  node: Collection!
}

input CollectionInput {
  name: String!
  productsIds: [String!]
  ruleSet: CollectionRuleSetInput
}

enum CollectionOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

enum CollectionRuleField {
  PRICE
  TITLE
  TYPE
}

enum CollectionRuleRelation {
  CONTAINS
  ENDS_WITH
  EQUALS
  GREATER_THAN
  LESS_THAN
  NOT_CONTAINS
  NOT_EQUALS
  STARTS_WITH
}

input CollectionRuleSetInput {
  applyDisjunctively: Boolean!
  rules: [RulesInput!]!
}

input CollectionRuleSetWhereInput {
  AND: [CollectionRuleSetWhereInput!]
  appliesDisjunctively: Boolean
  appliesDisjunctively_not: Boolean
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CollectionRuleSetWhereInput!]
  OR: [CollectionRuleSetWhereInput!]
  rules_every: CollectionRuleWhereInput
  rules_none: CollectionRuleWhereInput
  rules_some: CollectionRuleWhereInput
}

input CollectionRuleWhereInput {
  AND: [CollectionRuleWhereInput!]
  field: CollectionRuleField
  field_in: [CollectionRuleField!]
  field_not: CollectionRuleField
  field_not_in: [CollectionRuleField!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CollectionRuleWhereInput!]
  OR: [CollectionRuleWhereInput!]
  relation: CollectionRuleRelation
  relation_in: [CollectionRuleRelation!]
  relation_not: CollectionRuleRelation
  relation_not_in: [CollectionRuleRelation!]
  value: String
  value_contains: String
  value_ends_with: String
  value_gt: String
  value_gte: String
  value_in: [String!]
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_ends_with: String
  value_not_in: [String!]
  value_not_starts_with: String
  value_starts_with: String
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  products_every: ProductWhereInput
  products_none: ProductWhereInput
  products_some: ProductWhereInput
  rules: CollectionRuleSetWhereInput
}

input CreateProductInput {
  attributesIds: [UniqueInput!]!
  brand: UniqueInput!
  name: String!
  slug: String!
  variants: [CreateVariantInput!]!
}

input CreateVariantInput {
  availableForSale: Boolean!
  optionsValueIds: [UniqueInput!]!
  price: Int!
}

type Image {
  id: ID!
  url: String!
}

enum ImageOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  url_ASC
  url_DESC
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  url: String
  url_contains: String
  url_ends_with: String
  url_gt: String
  url_gte: String
  url_in: [String!]
  url_lt: String
  url_lte: String
  url_not: String
  url_not_contains: String
  url_not_ends_with: String
  url_not_in: [String!]
  url_not_starts_with: String
  url_starts_with: String
}

type Mutation {
  addToCart(variantId: ID!): Boolean!
  collectionAddProducts(collectionId: ID!, productIds: [ID!]!): Collection!
  collectionCreate(collection: CollectionInput!): Collection!
  collectionRemoveProducts(collectionId: ID!, productIds: [ID!]!): Collection!
  collectionUpdate(collection: CollectionInput!, id: ID!): Collection!
  productCreate(data: CreateProductInput!): Product!
  productDelete(productId: ID!): Product!
  productUpdate(data: UpdateProductInput!): Product!
  removeFromCart(variantId: ID!): Boolean!
}

type Option {
  id: ID!
  isColor: Boolean!
  name: String!
  values(after: String, before: String, first: Int, last: Int, orderBy: OptionValueOrderByInput, skip: Int, where: OptionValueWhereInput): [OptionValue!]
}

type OptionConnection {
  aggregate: AggregateOption!
  edges: [OptionEdge!]!
  pageInfo: PageInfo!
}

type OptionEdge {
  cursor: String!
  node: Option!
}

enum OptionOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isColor_ASC
  isColor_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OptionValue {
  id: ID!
  name: String!
  option: Option!
}

enum OptionValueOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input OptionValueWhereInput {
  AND: [OptionValueWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [OptionValueWhereInput!]
  option: OptionWhereInput
  OR: [OptionValueWhereInput!]
}

input OptionWhereInput {
  AND: [OptionWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isColor: Boolean
  isColor_not: Boolean
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [OptionWhereInput!]
  OR: [OptionWhereInput!]
  values_every: OptionValueWhereInput
  values_none: OptionValueWhereInput
  values_some: OptionValueWhereInput
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Product {
  attributes: [Attribute!]!
  brand: Brand!
  description: String!
  id: ID!
  name: String!
  slug: String!
  thumbnail: Image!
  type: ProductType
  variants(after: String, before: String, first: Int, last: Int, orderBy: VariantOrderByInput, skip: Int, where: VariantWhereInput): [Variant!]
}

type ProductConnection {
  aggregate: AggregateProduct!
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
}

type ProductEdge {
  cursor: String!
  node: Product!
}

enum ProductOrderByInput {
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  slug_ASC
  slug_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductType {
  id: ID!
  name: String!
}

input ProductTypeWhereInput {
  AND: [ProductTypeWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductTypeWhereInput!]
  OR: [ProductTypeWhereInput!]
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  attributes_every: AttributeWhereInput
  attributes_none: AttributeWhereInput
  attributes_some: AttributeWhereInput
  brand: BrandWhereInput
  collections_every: CollectionWhereInput
  collections_none: CollectionWhereInput
  collections_some: CollectionWhereInput
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  thumbnail: ImageWhereInput
  type: ProductTypeWhereInput
  variants_every: VariantWhereInput
  variants_none: VariantWhereInput
  variants_some: VariantWhereInput
}

input ProductWhereUniqueInput {
  id: ID
  slug: String
}

type Query {
  brands(after: String, before: String, first: Int, last: Int, orderBy: BrandOrderByInput, skip: Int, where: BrandWhereInput): BrandConnection!
  collection(collectionId: ID!): Collection!
  collections(after: String, before: String, first: Int, last: Int, orderBy: CollectionOrderByInput, skip: Int, where: CollectionWhereInput): CollectionConnection!
  options(after: String, before: String, first: Int, last: Int, orderBy: OptionOrderByInput, skip: Int, where: OptionWhereInput): OptionConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): ProductConnection!
}

input RulesInput {
  field: CollectionRuleField!
  relation: CollectionRuleRelation!
  value: String!
}

input UniqueInput {
  id: ID!
}

input UpdateProductInput {
  attributesIds: [UniqueInput!]!
  brand: UniqueInput!
  id: ID!
  name: String!
  variants: [UpdateVariantInput!]!
}

input UpdateVariantInput {
  availableForSale: Boolean!
  id: ID!
  optionsValueIds: [UniqueInput!]!
  price: Int!
}

type Variant {
  availableForSale: Boolean
  id: ID!
  images(after: String, before: String, first: Int, last: Int, orderBy: ImageOrderByInput, skip: Int, where: ImageWhereInput): [Image!]
  optionValues(after: String, before: String, first: Int, last: Int, orderBy: OptionValueOrderByInput, skip: Int, where: OptionValueWhereInput): [OptionValue!]
  price: Int!
  sku: String
}

enum VariantOrderByInput {
  availableForSale_ASC
  availableForSale_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  sku_ASC
  sku_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input VariantWhereInput {
  AND: [VariantWhereInput!]
  availableForSale: Boolean
  availableForSale_not: Boolean
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  images_every: ImageWhereInput
  images_none: ImageWhereInput
  images_some: ImageWhereInput
  NOT: [VariantWhereInput!]
  optionValues_every: OptionValueWhereInput
  optionValues_none: OptionValueWhereInput
  optionValues_some: OptionValueWhereInput
  OR: [VariantWhereInput!]
  price: Int
  price_gt: Int
  price_gte: Int
  price_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_not: Int
  price_not_in: [Int!]
  sku: String
  sku_contains: String
  sku_ends_with: String
  sku_gt: String
  sku_gte: String
  sku_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_not: String
  sku_not_contains: String
  sku_not_ends_with: String
  sku_not_in: [String!]
  sku_not_starts_with: String
  sku_starts_with: String
}
