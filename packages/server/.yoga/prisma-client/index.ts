// Code generated by Prisma (prisma@1.31.0-beta.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attribute: (where?: AttributeWhereInput) => Promise<boolean>;
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  collection: (where?: CollectionWhereInput) => Promise<boolean>;
  collectionRule: (where?: CollectionRuleWhereInput) => Promise<boolean>;
  collectionRuleSet: (where?: CollectionRuleSetWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  optionValue: (where?: OptionValueWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  orderLineItem: (where?: OrderLineItemWhereInput) => Promise<boolean>;
  orderOptionValues: (where?: OrderOptionValuesWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productType: (where?: ProductTypeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  variant: (where?: VariantWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  attributes: (args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Attribute>;
  attributesConnection: (args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AttributeConnectionPromise;
  brand: (where: BrandWhereUniqueInput) => BrandPromise;
  brands: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Brand>;
  brandsConnection: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrandConnectionPromise;
  collection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  collections: (args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Collection>;
  collectionsConnection: (args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CollectionConnectionPromise;
  collectionRule: (
    where: CollectionRuleWhereUniqueInput
  ) => CollectionRulePromise;
  collectionRules: (args?: {
    where?: CollectionRuleWhereInput;
    orderBy?: CollectionRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CollectionRule>;
  collectionRulesConnection: (args?: {
    where?: CollectionRuleWhereInput;
    orderBy?: CollectionRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CollectionRuleConnectionPromise;
  collectionRuleSet: (
    where: CollectionRuleSetWhereUniqueInput
  ) => CollectionRuleSetPromise;
  collectionRuleSets: (args?: {
    where?: CollectionRuleSetWhereInput;
    orderBy?: CollectionRuleSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CollectionRuleSet>;
  collectionRuleSetsConnection: (args?: {
    where?: CollectionRuleSetWhereInput;
    orderBy?: CollectionRuleSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CollectionRuleSetConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionPromise;
  options: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Option>;
  optionsConnection: (args?: {
    where?: OptionWhereInput;
    orderBy?: OptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionConnectionPromise;
  optionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  optionValues: (args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OptionValue>;
  optionValuesConnection: (args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptionValueConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  orderLineItem: (where: OrderLineItemWhereUniqueInput) => OrderLineItemPromise;
  orderLineItems: (args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderLineItem>;
  orderLineItemsConnection: (args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderLineItemConnectionPromise;
  orderOptionValues: (
    where: OrderOptionValuesWhereUniqueInput
  ) => OrderOptionValuesPromise;
  orderOptionValueses: (args?: {
    where?: OrderOptionValuesWhereInput;
    orderBy?: OrderOptionValuesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderOptionValues>;
  orderOptionValuesesConnection: (args?: {
    where?: OrderOptionValuesWhereInput;
    orderBy?: OrderOptionValuesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderOptionValuesConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productType: (where: ProductTypeWhereUniqueInput) => ProductTypePromise;
  productTypes: (args?: {
    where?: ProductTypeWhereInput;
    orderBy?: ProductTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductType>;
  productTypesConnection: (args?: {
    where?: ProductTypeWhereInput;
    orderBy?: ProductTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductTypeConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  variant: (where: VariantWhereUniqueInput) => VariantPromise;
  variants: (args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Variant>;
  variantsConnection: (args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VariantConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttribute: (data: AttributeCreateInput) => AttributePromise;
  updateAttribute: (args: {
    data: AttributeUpdateInput;
    where: AttributeWhereUniqueInput;
  }) => AttributePromise;
  updateManyAttributes: (args: {
    data: AttributeUpdateManyMutationInput;
    where?: AttributeWhereInput;
  }) => BatchPayloadPromise;
  upsertAttribute: (args: {
    where: AttributeWhereUniqueInput;
    create: AttributeCreateInput;
    update: AttributeUpdateInput;
  }) => AttributePromise;
  deleteAttribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  deleteManyAttributes: (where?: AttributeWhereInput) => BatchPayloadPromise;
  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (args: {
    data: BrandUpdateInput;
    where: BrandWhereUniqueInput;
  }) => BrandPromise;
  updateManyBrands: (args: {
    data: BrandUpdateManyMutationInput;
    where?: BrandWhereInput;
  }) => BatchPayloadPromise;
  upsertBrand: (args: {
    where: BrandWhereUniqueInput;
    create: BrandCreateInput;
    update: BrandUpdateInput;
  }) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCollection: (data: CollectionCreateInput) => CollectionPromise;
  updateCollection: (args: {
    data: CollectionUpdateInput;
    where: CollectionWhereUniqueInput;
  }) => CollectionPromise;
  updateManyCollections: (args: {
    data: CollectionUpdateManyMutationInput;
    where?: CollectionWhereInput;
  }) => BatchPayloadPromise;
  upsertCollection: (args: {
    where: CollectionWhereUniqueInput;
    create: CollectionCreateInput;
    update: CollectionUpdateInput;
  }) => CollectionPromise;
  deleteCollection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  deleteManyCollections: (where?: CollectionWhereInput) => BatchPayloadPromise;
  createCollectionRule: (
    data: CollectionRuleCreateInput
  ) => CollectionRulePromise;
  updateCollectionRule: (args: {
    data: CollectionRuleUpdateInput;
    where: CollectionRuleWhereUniqueInput;
  }) => CollectionRulePromise;
  updateManyCollectionRules: (args: {
    data: CollectionRuleUpdateManyMutationInput;
    where?: CollectionRuleWhereInput;
  }) => BatchPayloadPromise;
  upsertCollectionRule: (args: {
    where: CollectionRuleWhereUniqueInput;
    create: CollectionRuleCreateInput;
    update: CollectionRuleUpdateInput;
  }) => CollectionRulePromise;
  deleteCollectionRule: (
    where: CollectionRuleWhereUniqueInput
  ) => CollectionRulePromise;
  deleteManyCollectionRules: (
    where?: CollectionRuleWhereInput
  ) => BatchPayloadPromise;
  createCollectionRuleSet: (
    data: CollectionRuleSetCreateInput
  ) => CollectionRuleSetPromise;
  updateCollectionRuleSet: (args: {
    data: CollectionRuleSetUpdateInput;
    where: CollectionRuleSetWhereUniqueInput;
  }) => CollectionRuleSetPromise;
  updateManyCollectionRuleSets: (args: {
    data: CollectionRuleSetUpdateManyMutationInput;
    where?: CollectionRuleSetWhereInput;
  }) => BatchPayloadPromise;
  upsertCollectionRuleSet: (args: {
    where: CollectionRuleSetWhereUniqueInput;
    create: CollectionRuleSetCreateInput;
    update: CollectionRuleSetUpdateInput;
  }) => CollectionRuleSetPromise;
  deleteCollectionRuleSet: (
    where: CollectionRuleSetWhereUniqueInput
  ) => CollectionRuleSetPromise;
  deleteManyCollectionRuleSets: (
    where?: CollectionRuleSetWhereInput
  ) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (args: {
    data: OptionUpdateInput;
    where: OptionWhereUniqueInput;
  }) => OptionPromise;
  updateManyOptions: (args: {
    data: OptionUpdateManyMutationInput;
    where?: OptionWhereInput;
  }) => BatchPayloadPromise;
  upsertOption: (args: {
    where: OptionWhereUniqueInput;
    create: OptionCreateInput;
    update: OptionUpdateInput;
  }) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createOptionValue: (data: OptionValueCreateInput) => OptionValuePromise;
  updateOptionValue: (args: {
    data: OptionValueUpdateInput;
    where: OptionValueWhereUniqueInput;
  }) => OptionValuePromise;
  updateManyOptionValues: (args: {
    data: OptionValueUpdateManyMutationInput;
    where?: OptionValueWhereInput;
  }) => BatchPayloadPromise;
  upsertOptionValue: (args: {
    where: OptionValueWhereUniqueInput;
    create: OptionValueCreateInput;
    update: OptionValueUpdateInput;
  }) => OptionValuePromise;
  deleteOptionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  deleteManyOptionValues: (
    where?: OptionValueWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createOrderLineItem: (data: OrderLineItemCreateInput) => OrderLineItemPromise;
  updateOrderLineItem: (args: {
    data: OrderLineItemUpdateInput;
    where: OrderLineItemWhereUniqueInput;
  }) => OrderLineItemPromise;
  updateManyOrderLineItems: (args: {
    data: OrderLineItemUpdateManyMutationInput;
    where?: OrderLineItemWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderLineItem: (args: {
    where: OrderLineItemWhereUniqueInput;
    create: OrderLineItemCreateInput;
    update: OrderLineItemUpdateInput;
  }) => OrderLineItemPromise;
  deleteOrderLineItem: (
    where: OrderLineItemWhereUniqueInput
  ) => OrderLineItemPromise;
  deleteManyOrderLineItems: (
    where?: OrderLineItemWhereInput
  ) => BatchPayloadPromise;
  createOrderOptionValues: (
    data: OrderOptionValuesCreateInput
  ) => OrderOptionValuesPromise;
  updateOrderOptionValues: (args: {
    data: OrderOptionValuesUpdateInput;
    where: OrderOptionValuesWhereUniqueInput;
  }) => OrderOptionValuesPromise;
  updateManyOrderOptionValueses: (args: {
    data: OrderOptionValuesUpdateManyMutationInput;
    where?: OrderOptionValuesWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderOptionValues: (args: {
    where: OrderOptionValuesWhereUniqueInput;
    create: OrderOptionValuesCreateInput;
    update: OrderOptionValuesUpdateInput;
  }) => OrderOptionValuesPromise;
  deleteOrderOptionValues: (
    where: OrderOptionValuesWhereUniqueInput
  ) => OrderOptionValuesPromise;
  deleteManyOrderOptionValueses: (
    where?: OrderOptionValuesWhereInput
  ) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductType: (data: ProductTypeCreateInput) => ProductTypePromise;
  updateProductType: (args: {
    data: ProductTypeUpdateInput;
    where: ProductTypeWhereUniqueInput;
  }) => ProductTypePromise;
  updateManyProductTypes: (args: {
    data: ProductTypeUpdateManyMutationInput;
    where?: ProductTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertProductType: (args: {
    where: ProductTypeWhereUniqueInput;
    create: ProductTypeCreateInput;
    update: ProductTypeUpdateInput;
  }) => ProductTypePromise;
  deleteProductType: (where: ProductTypeWhereUniqueInput) => ProductTypePromise;
  deleteManyProductTypes: (
    where?: ProductTypeWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVariant: (data: VariantCreateInput) => VariantPromise;
  updateVariant: (args: {
    data: VariantUpdateInput;
    where: VariantWhereUniqueInput;
  }) => VariantPromise;
  updateManyVariants: (args: {
    data: VariantUpdateManyMutationInput;
    where?: VariantWhereInput;
  }) => BatchPayloadPromise;
  upsertVariant: (args: {
    where: VariantWhereUniqueInput;
    create: VariantCreateInput;
    update: VariantUpdateInput;
  }) => VariantPromise;
  deleteVariant: (where: VariantWhereUniqueInput) => VariantPromise;
  deleteManyVariants: (where?: VariantWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attribute: (
    where?: AttributeSubscriptionWhereInput
  ) => AttributeSubscriptionPayloadSubscription;
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  collection: (
    where?: CollectionSubscriptionWhereInput
  ) => CollectionSubscriptionPayloadSubscription;
  collectionRule: (
    where?: CollectionRuleSubscriptionWhereInput
  ) => CollectionRuleSubscriptionPayloadSubscription;
  collectionRuleSet: (
    where?: CollectionRuleSetSubscriptionWhereInput
  ) => CollectionRuleSetSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  optionValue: (
    where?: OptionValueSubscriptionWhereInput
  ) => OptionValueSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  orderLineItem: (
    where?: OrderLineItemSubscriptionWhereInput
  ) => OrderLineItemSubscriptionPayloadSubscription;
  orderOptionValues: (
    where?: OrderOptionValuesSubscriptionWhereInput
  ) => OrderOptionValuesSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productType: (
    where?: ProductTypeSubscriptionWhereInput
  ) => ProductTypeSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  variant: (
    where?: VariantSubscriptionWhereInput
  ) => VariantSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "isColor_ASC"
  | "isColor_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "availableForSale_ASC"
  | "availableForSale_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleSetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "appliesDisjunctively_ASC"
  | "appliesDisjunctively_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "method_ASC"
  | "method_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "state_ASC"
  | "state_DESC"
  | "currencyCode_ASC"
  | "currencyCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleField = "TYPE" | "TITLE" | "PRICE";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "subTotalBeforeTax_ASC"
  | "subTotalBeforeTax_DESC"
  | "subTotal_ASC"
  | "subTotal_DESC"
  | "state_ASC"
  | "state_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleRelation =
  | "CONTAINS"
  | "ENDS_WITH"
  | "EQUALS"
  | "GREATER_THAN"
  | "LESS_THAN"
  | "NOT_CONTAINS"
  | "NOT_EQUALS"
  | "STARTS_WITH";

export type OrderState = "COMPLETE" | "CANCELLED";

export type AttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentState =
  | "AUTHORIZED"
  | "SETTLED"
  | "DECLINED"
  | "REFUNDED"
  | "CANCELLED";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type OptionValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "field_ASC"
  | "field_DESC"
  | "relation_ASC"
  | "relation_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentMethod = "PAYPAL" | "STRIPE" | "CREDIT_CARD";

export type CurrencyCode = "EUR" | "USD";

export type OrderLineItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "unitPrice_ASC"
  | "unitPrice_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOptionValuesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "optionName_ASC"
  | "optionName_DESC"
  | "optionValue_ASC"
  | "optionValue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface VariantUpdateManyDataInput {
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export type AttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CollectionRuleSetCreateInput {
  rules?: CollectionRuleCreateManyInput;
  appliesDisjunctively: Boolean;
}

export interface OrderOptionValuesCreateInput {
  optionName: String;
  optionValue: String;
}

export interface CollectionRuleCreateManyInput {
  create?: CollectionRuleCreateInput[] | CollectionRuleCreateInput;
  connect?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
}

export interface CollectionRuleSetUpsertNestedInput {
  update: CollectionRuleSetUpdateDataInput;
  create: CollectionRuleSetCreateInput;
}

export interface CollectionRuleCreateInput {
  field: CollectionRuleField;
  relation: CollectionRuleRelation;
  value: String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface AttributeUpdateInput {
  key?: String;
  value?: String;
  products?: ProductUpdateManyWithoutAttributesInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface ProductUpdateManyWithoutAttributesInput {
  create?:
    | ProductCreateWithoutAttributesInput[]
    | ProductCreateWithoutAttributesInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutAttributesInput[]
    | ProductUpdateWithWhereUniqueWithoutAttributesInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutAttributesInput[]
    | ProductUpsertWithWhereUniqueWithoutAttributesInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface OrderOptionValuesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderOptionValuesWhereInput;
  AND?:
    | OrderOptionValuesSubscriptionWhereInput[]
    | OrderOptionValuesSubscriptionWhereInput;
  OR?:
    | OrderOptionValuesSubscriptionWhereInput[]
    | OrderOptionValuesSubscriptionWhereInput;
  NOT?:
    | OrderOptionValuesSubscriptionWhereInput[]
    | OrderOptionValuesSubscriptionWhereInput;
}

export interface ProductUpdateWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutAttributesDataInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface ProductUpdateWithoutAttributesDataInput {
  slug?: String;
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
}

export interface OptionValueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionValueWhereInput;
  AND?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
  OR?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
  NOT?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
}

export interface BrandUpdateOneRequiredWithoutProductsInput {
  create?: BrandCreateWithoutProductsInput;
  update?: BrandUpdateWithoutProductsDataInput;
  upsert?: BrandUpsertWithoutProductsInput;
  connect?: BrandWhereUniqueInput;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  OR?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  NOT?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface BrandUpdateWithoutProductsDataInput {
  name?: String;
}

export type BrandWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput;
  create: BrandCreateWithoutProductsInput;
}

export interface CollectionRuleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionRuleWhereInput;
  AND?:
    | CollectionRuleSubscriptionWhereInput[]
    | CollectionRuleSubscriptionWhereInput;
  OR?:
    | CollectionRuleSubscriptionWhereInput[]
    | CollectionRuleSubscriptionWhereInput;
  NOT?:
    | CollectionRuleSubscriptionWhereInput[]
    | CollectionRuleSubscriptionWhereInput;
}

export interface ProductTypeUpdateOneInput {
  create?: ProductTypeCreateInput;
  update?: ProductTypeUpdateDataInput;
  upsert?: ProductTypeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductTypeWhereUniqueInput;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BrandWhereInput;
  AND?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
  OR?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
  NOT?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
}

export interface ProductTypeUpdateDataInput {
  name?: String;
}

export interface AttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttributeWhereInput;
  AND?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  OR?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  NOT?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
}

export interface ProductTypeUpsertNestedInput {
  update: ProductTypeUpdateDataInput;
  create: ProductTypeCreateInput;
}

export interface VariantUpdateInput {
  optionValues?: OptionValueUpdateManyInput;
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
  images?: ImageUpdateManyInput;
}

export interface ImageUpdateOneRequiredInput {
  create?: ImageCreateInput;
  update?: ImageUpdateDataInput;
  upsert?: ImageUpsertNestedInput;
  connect?: ImageWhereUniqueInput;
}

export interface UserUpdateInput {
  orders?: OrderUpdateManyWithoutCustomerInput;
  cart?: VariantUpdateManyInput;
}

export interface ImageUpdateDataInput {
  url?: String;
}

export interface ProductTypeUpdateInput {
  name?: String;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface CollectionRuleSetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rules_every?: CollectionRuleWhereInput;
  rules_some?: CollectionRuleWhereInput;
  rules_none?: CollectionRuleWhereInput;
  appliesDisjunctively?: Boolean;
  appliesDisjunctively_not?: Boolean;
  AND?: CollectionRuleSetWhereInput[] | CollectionRuleSetWhereInput;
  OR?: CollectionRuleSetWhereInput[] | CollectionRuleSetWhereInput;
  NOT?: CollectionRuleSetWhereInput[] | CollectionRuleSetWhereInput;
}

export interface VariantUpdateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  update?:
    | VariantUpdateWithWhereUniqueNestedInput[]
    | VariantUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VariantUpsertWithWhereUniqueNestedInput[]
    | VariantUpsertWithWhereUniqueNestedInput;
  delete?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  set?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  disconnect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  deleteMany?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  updateMany?:
    | VariantUpdateManyWithWhereNestedInput[]
    | VariantUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateInput {
  slug?: String;
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface VariantUpdateWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  data: VariantUpdateDataInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VariantUpdateDataInput {
  optionValues?: OptionValueUpdateManyInput;
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
  images?: ImageUpdateManyInput;
}

export interface OrderUpsertWithoutPaymentInput {
  update: OrderUpdateWithoutPaymentDataInput;
  create: OrderCreateWithoutPaymentInput;
}

export interface OptionValueUpdateManyInput {
  create?: OptionValueCreateInput[] | OptionValueCreateInput;
  update?:
    | OptionValueUpdateWithWhereUniqueNestedInput[]
    | OptionValueUpdateWithWhereUniqueNestedInput;
  upsert?:
    | OptionValueUpsertWithWhereUniqueNestedInput[]
    | OptionValueUpsertWithWhereUniqueNestedInput;
  delete?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  set?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  disconnect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  deleteMany?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  updateMany?:
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput;
}

export type OptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface OptionValueUpdateWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateDataInput;
}

export interface OrderUpdateOneRequiredWithoutPaymentInput {
  create?: OrderCreateWithoutPaymentInput;
  update?: OrderUpdateWithoutPaymentDataInput;
  upsert?: OrderUpsertWithoutPaymentInput;
  connect?: OrderWhereUniqueInput;
}

export interface OptionValueUpdateDataInput {
  name?: String;
  option?: OptionUpdateOneRequiredWithoutValuesInput;
}

export interface OrderCreateWithoutPaymentInput {
  items?: OrderLineItemCreateManyInput;
  customer: UserCreateOneWithoutOrdersInput;
  subTotalBeforeTax: Int;
  subTotal: Int;
  state: OrderState;
}

export interface OptionUpdateOneRequiredWithoutValuesInput {
  create?: OptionCreateWithoutValuesInput;
  update?: OptionUpdateWithoutValuesDataInput;
  upsert?: OptionUpsertWithoutValuesInput;
  connect?: OptionWhereUniqueInput;
}

export interface OrderCreateOneWithoutPaymentInput {
  create?: OrderCreateWithoutPaymentInput;
  connect?: OrderWhereUniqueInput;
}

export interface OptionUpdateWithoutValuesDataInput {
  name?: String;
  isColor?: Boolean;
}

export interface OrderOptionValuesUpdateManyMutationInput {
  optionName?: String;
  optionValue?: String;
}

export interface OptionUpsertWithoutValuesInput {
  update: OptionUpdateWithoutValuesDataInput;
  create: OptionCreateWithoutValuesInput;
}

export interface OrderOptionValuesUpdateInput {
  optionName?: String;
  optionValue?: String;
}

export interface OptionValueUpsertWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateDataInput;
  create: OptionValueCreateInput;
}

export interface OrderLineItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: UserWhereInput;
  image?: ImageWhereInput;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  unitPrice?: Int;
  unitPrice_not?: Int;
  unitPrice_in?: Int[] | Int;
  unitPrice_not_in?: Int[] | Int;
  unitPrice_lt?: Int;
  unitPrice_lte?: Int;
  unitPrice_gt?: Int;
  unitPrice_gte?: Int;
  sku?: String;
  sku_not?: String;
  sku_in?: String[] | String;
  sku_not_in?: String[] | String;
  sku_lt?: String;
  sku_lte?: String;
  sku_gt?: String;
  sku_gte?: String;
  sku_contains?: String;
  sku_not_contains?: String;
  sku_starts_with?: String;
  sku_not_starts_with?: String;
  sku_ends_with?: String;
  sku_not_ends_with?: String;
  orderOptionValues_every?: OrderOptionValuesWhereInput;
  orderOptionValues_some?: OrderOptionValuesWhereInput;
  orderOptionValues_none?: OrderOptionValuesWhereInput;
  AND?: OrderLineItemWhereInput[] | OrderLineItemWhereInput;
  OR?: OrderLineItemWhereInput[] | OrderLineItemWhereInput;
  NOT?: OrderLineItemWhereInput[] | OrderLineItemWhereInput;
}

export interface OptionValueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  OR?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  NOT?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
}

export interface OrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  items_every?: OrderLineItemWhereInput;
  items_some?: OrderLineItemWhereInput;
  items_none?: OrderLineItemWhereInput;
  customer?: UserWhereInput;
  subTotalBeforeTax?: Int;
  subTotalBeforeTax_not?: Int;
  subTotalBeforeTax_in?: Int[] | Int;
  subTotalBeforeTax_not_in?: Int[] | Int;
  subTotalBeforeTax_lt?: Int;
  subTotalBeforeTax_lte?: Int;
  subTotalBeforeTax_gt?: Int;
  subTotalBeforeTax_gte?: Int;
  subTotal?: Int;
  subTotal_not?: Int;
  subTotal_in?: Int[] | Int;
  subTotal_not_in?: Int[] | Int;
  subTotal_lt?: Int;
  subTotal_lte?: Int;
  subTotal_gt?: Int;
  subTotal_gte?: Int;
  payment?: PaymentWhereInput;
  state?: OrderState;
  state_not?: OrderState;
  state_in?: OrderState[] | OrderState;
  state_not_in?: OrderState[] | OrderState;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export interface OptionValueUpdateManyWithWhereNestedInput {
  where: OptionValueScalarWhereInput;
  data: OptionValueUpdateManyDataInput;
}

export interface OrderLineItemUpdateInput {
  owner?: UserUpdateOneInput;
  image?: ImageUpdateOneRequiredInput;
  quantity?: Int;
  unitPrice?: Int;
  sku?: String;
  orderOptionValues?: OrderOptionValuesUpdateManyInput;
}

export interface OptionValueUpdateManyDataInput {
  name?: String;
}

export interface OptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  isColor?: Boolean;
  isColor_not?: Boolean;
  values_every?: OptionValueWhereInput;
  values_some?: OptionValueWhereInput;
  values_none?: OptionValueWhereInput;
  AND?: OptionWhereInput[] | OptionWhereInput;
  OR?: OptionWhereInput[] | OptionWhereInput;
  NOT?: OptionWhereInput[] | OptionWhereInput;
}

export interface ImageUpdateManyInput {
  create?: ImageCreateInput[] | ImageCreateInput;
  update?:
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput;
  delete?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  set?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  disconnect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  deleteMany?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  updateMany?:
    | ImageUpdateManyWithWhereNestedInput[]
    | ImageUpdateManyWithWhereNestedInput;
}

export interface OrderOptionValuesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  optionName?: String;
  optionName_not?: String;
  optionName_in?: String[] | String;
  optionName_not_in?: String[] | String;
  optionName_lt?: String;
  optionName_lte?: String;
  optionName_gt?: String;
  optionName_gte?: String;
  optionName_contains?: String;
  optionName_not_contains?: String;
  optionName_starts_with?: String;
  optionName_not_starts_with?: String;
  optionName_ends_with?: String;
  optionName_not_ends_with?: String;
  optionValue?: String;
  optionValue_not?: String;
  optionValue_in?: String[] | String;
  optionValue_not_in?: String[] | String;
  optionValue_lt?: String;
  optionValue_lte?: String;
  optionValue_gt?: String;
  optionValue_gte?: String;
  optionValue_contains?: String;
  optionValue_not_contains?: String;
  optionValue_starts_with?: String;
  optionValue_not_starts_with?: String;
  optionValue_ends_with?: String;
  optionValue_not_ends_with?: String;
  AND?: OrderOptionValuesWhereInput[] | OrderOptionValuesWhereInput;
  OR?: OrderOptionValuesWhereInput[] | OrderOptionValuesWhereInput;
  NOT?: OrderOptionValuesWhereInput[] | OrderOptionValuesWhereInput;
}

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput;
  create: UserCreateWithoutOrdersInput;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageWhereInput[] | ImageWhereInput;
  OR?: ImageWhereInput[] | ImageWhereInput;
  NOT?: ImageWhereInput[] | ImageWhereInput;
}

export interface ImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  OR?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  NOT?: ImageScalarWhereInput[] | ImageScalarWhereInput;
}

export interface UserUpdateOneRequiredWithoutOrdersInput {
  create?: UserCreateWithoutOrdersInput;
  update?: UserUpdateWithoutOrdersDataInput;
  upsert?: UserUpsertWithoutOrdersInput;
  connect?: UserWhereUniqueInput;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface OrderLineItemUpdateManyWithWhereNestedInput {
  where: OrderLineItemScalarWhereInput;
  data: OrderLineItemUpdateManyDataInput;
}

export interface ImageUpdateManyDataInput {
  url?: String;
}

export interface OrderLineItemUpsertWithWhereUniqueNestedInput {
  where: OrderLineItemWhereUniqueInput;
  update: OrderLineItemUpdateDataInput;
  create: OrderLineItemCreateInput;
}

export interface VariantUpsertWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  update: VariantUpdateDataInput;
  create: VariantCreateInput;
}

export interface OrderOptionValuesUpdateManyDataInput {
  optionName?: String;
  optionValue?: String;
}

export interface VariantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  availableForSale?: Boolean;
  availableForSale_not?: Boolean;
  sku?: String;
  sku_not?: String;
  sku_in?: String[] | String;
  sku_not_in?: String[] | String;
  sku_lt?: String;
  sku_lte?: String;
  sku_gt?: String;
  sku_gte?: String;
  sku_contains?: String;
  sku_not_contains?: String;
  sku_starts_with?: String;
  sku_not_starts_with?: String;
  sku_ends_with?: String;
  sku_not_ends_with?: String;
  AND?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  OR?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  NOT?: VariantScalarWhereInput[] | VariantScalarWhereInput;
}

export interface OrderOptionValuesScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  optionName?: String;
  optionName_not?: String;
  optionName_in?: String[] | String;
  optionName_not_in?: String[] | String;
  optionName_lt?: String;
  optionName_lte?: String;
  optionName_gt?: String;
  optionName_gte?: String;
  optionName_contains?: String;
  optionName_not_contains?: String;
  optionName_starts_with?: String;
  optionName_not_starts_with?: String;
  optionName_ends_with?: String;
  optionName_not_ends_with?: String;
  optionValue?: String;
  optionValue_not?: String;
  optionValue_in?: String[] | String;
  optionValue_not_in?: String[] | String;
  optionValue_lt?: String;
  optionValue_lte?: String;
  optionValue_gt?: String;
  optionValue_gte?: String;
  optionValue_contains?: String;
  optionValue_not_contains?: String;
  optionValue_starts_with?: String;
  optionValue_not_starts_with?: String;
  optionValue_ends_with?: String;
  optionValue_not_ends_with?: String;
  AND?: OrderOptionValuesScalarWhereInput[] | OrderOptionValuesScalarWhereInput;
  OR?: OrderOptionValuesScalarWhereInput[] | OrderOptionValuesScalarWhereInput;
  NOT?: OrderOptionValuesScalarWhereInput[] | OrderOptionValuesScalarWhereInput;
}

export interface VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput;
  data: VariantUpdateManyDataInput;
}

export interface OrderOptionValuesUpsertWithWhereUniqueNestedInput {
  where: OrderOptionValuesWhereUniqueInput;
  update: OrderOptionValuesUpdateDataInput;
  create: OrderOptionValuesCreateInput;
}

export interface OrderLineItemUpdateManyInput {
  create?: OrderLineItemCreateInput[] | OrderLineItemCreateInput;
  update?:
    | OrderLineItemUpdateWithWhereUniqueNestedInput[]
    | OrderLineItemUpdateWithWhereUniqueNestedInput;
  upsert?:
    | OrderLineItemUpsertWithWhereUniqueNestedInput[]
    | OrderLineItemUpsertWithWhereUniqueNestedInput;
  delete?: OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput;
  connect?: OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput;
  set?: OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput;
  disconnect?: OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput;
  deleteMany?: OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput;
  updateMany?:
    | OrderLineItemUpdateManyWithWhereNestedInput[]
    | OrderLineItemUpdateManyWithWhereNestedInput;
}

export interface OrderOptionValuesUpdateWithWhereUniqueNestedInput {
  where: OrderOptionValuesWhereUniqueInput;
  data: OrderOptionValuesUpdateDataInput;
}

export interface CollectionUpdateManyWithoutProductsInput {
  create?:
    | CollectionCreateWithoutProductsInput[]
    | CollectionCreateWithoutProductsInput;
  delete?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  connect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  set?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  disconnect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  update?:
    | CollectionUpdateWithWhereUniqueWithoutProductsInput[]
    | CollectionUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | CollectionUpsertWithWhereUniqueWithoutProductsInput[]
    | CollectionUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  updateMany?:
    | CollectionUpdateManyWithWhereNestedInput[]
    | CollectionUpdateManyWithWhereNestedInput;
}

export interface BrandWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: BrandWhereInput[] | BrandWhereInput;
  OR?: BrandWhereInput[] | BrandWhereInput;
  NOT?: BrandWhereInput[] | BrandWhereInput;
}

export interface CollectionUpdateWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput;
  data: CollectionUpdateWithoutProductsDataInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CollectionUpdateWithoutProductsDataInput {
  name?: String;
  rules?: CollectionRuleSetUpdateOneInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  slug?: String;
}>;

export interface CollectionRuleSetUpdateOneInput {
  create?: CollectionRuleSetCreateInput;
  update?: CollectionRuleSetUpdateDataInput;
  upsert?: CollectionRuleSetUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CollectionRuleSetWhereUniqueInput;
}

export interface OrderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  subTotalBeforeTax?: Int;
  subTotalBeforeTax_not?: Int;
  subTotalBeforeTax_in?: Int[] | Int;
  subTotalBeforeTax_not_in?: Int[] | Int;
  subTotalBeforeTax_lt?: Int;
  subTotalBeforeTax_lte?: Int;
  subTotalBeforeTax_gt?: Int;
  subTotalBeforeTax_gte?: Int;
  subTotal?: Int;
  subTotal_not?: Int;
  subTotal_in?: Int[] | Int;
  subTotal_not_in?: Int[] | Int;
  subTotal_lt?: Int;
  subTotal_lte?: Int;
  subTotal_gt?: Int;
  subTotal_gte?: Int;
  state?: OrderState;
  state_not?: OrderState;
  state_in?: OrderState[] | OrderState;
  state_not_in?: OrderState[] | OrderState;
  AND?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  OR?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  NOT?: OrderScalarWhereInput[] | OrderScalarWhereInput;
}

export interface CollectionRuleSetUpdateDataInput {
  rules?: CollectionRuleUpdateManyInput;
  appliesDisjunctively?: Boolean;
}

export type ProductTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CollectionRuleUpdateManyInput {
  create?: CollectionRuleCreateInput[] | CollectionRuleCreateInput;
  update?:
    | CollectionRuleUpdateWithWhereUniqueNestedInput[]
    | CollectionRuleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CollectionRuleUpsertWithWhereUniqueNestedInput[]
    | CollectionRuleUpsertWithWhereUniqueNestedInput;
  delete?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
  connect?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
  set?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
  disconnect?:
    | CollectionRuleWhereUniqueInput[]
    | CollectionRuleWhereUniqueInput;
  deleteMany?:
    | CollectionRuleScalarWhereInput[]
    | CollectionRuleScalarWhereInput;
  updateMany?:
    | CollectionRuleUpdateManyWithWhereNestedInput[]
    | CollectionRuleUpdateManyWithWhereNestedInput;
}

export interface PaymentUpsertWithoutOrderInput {
  update: PaymentUpdateWithoutOrderDataInput;
  create: PaymentCreateWithoutOrderInput;
}

export interface CollectionRuleUpdateWithWhereUniqueNestedInput {
  where: CollectionRuleWhereUniqueInput;
  data: CollectionRuleUpdateDataInput;
}

export interface PaymentUpdateOneRequiredWithoutOrderInput {
  create?: PaymentCreateWithoutOrderInput;
  update?: PaymentUpdateWithoutOrderDataInput;
  upsert?: PaymentUpsertWithoutOrderInput;
  connect?: PaymentWhereUniqueInput;
}

export interface CollectionRuleUpdateDataInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface OrderUpdateWithoutCustomerDataInput {
  items?: OrderLineItemUpdateManyInput;
  subTotalBeforeTax?: Int;
  subTotal?: Int;
  payment?: PaymentUpdateOneRequiredWithoutOrderInput;
  state?: OrderState;
}

export interface CollectionRuleUpsertWithWhereUniqueNestedInput {
  where: CollectionRuleWhereUniqueInput;
  update: CollectionRuleUpdateDataInput;
  create: CollectionRuleCreateInput;
}

export interface OrderUpdateManyWithoutCustomerInput {
  create?: OrderCreateWithoutCustomerInput[] | OrderCreateWithoutCustomerInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  set?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    | OrderUpdateWithWhereUniqueWithoutCustomerInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    | OrderUpsertWithWhereUniqueWithoutCustomerInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface CollectionRuleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: CollectionRuleField;
  field_not?: CollectionRuleField;
  field_in?: CollectionRuleField[] | CollectionRuleField;
  field_not_in?: CollectionRuleField[] | CollectionRuleField;
  relation?: CollectionRuleRelation;
  relation_not?: CollectionRuleRelation;
  relation_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  relation_not_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: CollectionRuleScalarWhereInput[] | CollectionRuleScalarWhereInput;
  OR?: CollectionRuleScalarWhereInput[] | CollectionRuleScalarWhereInput;
  NOT?: CollectionRuleScalarWhereInput[] | CollectionRuleScalarWhereInput;
}

export type VariantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CollectionRuleUpdateManyWithWhereNestedInput {
  where: CollectionRuleScalarWhereInput;
  data: CollectionRuleUpdateManyDataInput;
}

export interface OrderLineItemUpdateDataInput {
  owner?: UserUpdateOneInput;
  image?: ImageUpdateOneRequiredInput;
  quantity?: Int;
  unitPrice?: Int;
  sku?: String;
  orderOptionValues?: OrderOptionValuesUpdateManyInput;
}

export interface CollectionRuleUpdateManyDataInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface ProductCreateManyWithoutAttributesInput {
  create?:
    | ProductCreateWithoutAttributesInput[]
    | ProductCreateWithoutAttributesInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface OrderUpdateInput {
  items?: OrderLineItemUpdateManyInput;
  customer?: UserUpdateOneRequiredWithoutOrdersInput;
  subTotalBeforeTax?: Int;
  subTotal?: Int;
  payment?: PaymentUpdateOneRequiredWithoutOrderInput;
  state?: OrderState;
}

export interface BrandCreateOneWithoutProductsInput {
  create?: BrandCreateWithoutProductsInput;
  connect?: BrandWhereUniqueInput;
}

export interface CollectionUpsertWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput;
  update: CollectionUpdateWithoutProductsDataInput;
  create: CollectionCreateWithoutProductsInput;
}

export interface ProductTypeCreateOneInput {
  create?: ProductTypeCreateInput;
  connect?: ProductTypeWhereUniqueInput;
}

export interface CollectionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  OR?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  NOT?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
}

export interface ImageCreateOneInput {
  create?: ImageCreateInput;
  connect?: ImageWhereUniqueInput;
}

export interface CollectionUpdateManyWithWhereNestedInput {
  where: CollectionScalarWhereInput;
  data: CollectionUpdateManyDataInput;
}

export interface VariantCreateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
}

export interface CollectionUpdateManyDataInput {
  name?: String;
}

export interface OptionValueCreateManyInput {
  create?: OptionValueCreateInput[] | OptionValueCreateInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
}

export interface ProductUpsertWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutAttributesDataInput;
  create: ProductCreateWithoutAttributesInput;
}

export interface OptionCreateOneWithoutValuesInput {
  create?: OptionCreateWithoutValuesInput;
  connect?: OptionWhereUniqueInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface ImageCreateManyInput {
  create?: ImageCreateInput[] | ImageCreateInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface CollectionCreateWithoutProductsInput {
  name: String;
  rules?: CollectionRuleSetCreateOneInput;
}

export interface ProductUpdateManyDataInput {
  slug?: String;
  name?: String;
  description?: String;
}

export interface VariantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VariantWhereInput;
  AND?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  OR?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  NOT?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
}

export interface AttributeUpdateManyMutationInput {
  key?: String;
  value?: String;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface UserCreateWithoutOrdersInput {
  cart?: VariantCreateManyInput;
}

export interface AttributeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: AttributeWhereInput[] | AttributeWhereInput;
  OR?: AttributeWhereInput[] | AttributeWhereInput;
  NOT?: AttributeWhereInput[] | AttributeWhereInput;
}

export interface UserCreateOneWithoutOrdersInput {
  create?: UserCreateWithoutOrdersInput;
  connect?: UserWhereUniqueInput;
}

export interface CollectionRuleSetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionRuleSetWhereInput;
  AND?:
    | CollectionRuleSetSubscriptionWhereInput[]
    | CollectionRuleSetSubscriptionWhereInput;
  OR?:
    | CollectionRuleSetSubscriptionWhereInput[]
    | CollectionRuleSetSubscriptionWhereInput;
  NOT?:
    | CollectionRuleSetSubscriptionWhereInput[]
    | CollectionRuleSetSubscriptionWhereInput;
}

export interface BrandCreateInput {
  name: String;
  products?: ProductCreateManyWithoutBrandInput;
}

export interface CollectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionWhereInput;
  AND?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
  OR?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
  NOT?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
}

export interface ProductCreateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface VariantUpdateManyMutationInput {
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface ProductCreateWithoutBrandInput {
  slug: String;
  name: String;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface ProductTypeUpdateManyMutationInput {
  name?: String;
}

export interface AttributeCreateManyWithoutProductsInput {
  create?:
    | AttributeCreateWithoutProductsInput[]
    | AttributeCreateWithoutProductsInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
}

export interface ProductUpdateManyMutationInput {
  slug?: String;
  name?: String;
  description?: String;
}

export interface AttributeCreateWithoutProductsInput {
  key: String;
  value: String;
}

export interface PaymentUpdateManyMutationInput {
  method?: PaymentMethod;
  amount?: Int;
  state?: PaymentState;
  currencyCode?: CurrencyCode;
}

export interface BrandUpdateInput {
  name?: String;
  products?: ProductUpdateManyWithoutBrandInput;
}

export interface CollectionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rules?: CollectionRuleSetWhereInput;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: CollectionWhereInput[] | CollectionWhereInput;
  OR?: CollectionWhereInput[] | CollectionWhereInput;
  NOT?: CollectionWhereInput[] | CollectionWhereInput;
}

export interface ProductUpdateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    | ProductUpdateWithWhereUniqueWithoutBrandInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    | ProductUpsertWithWhereUniqueWithoutBrandInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export type OptionValueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutBrandDataInput;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpdateWithoutBrandDataInput {
  slug?: String;
  name?: String;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  orders_every?: OrderWhereInput;
  orders_some?: OrderWhereInput;
  orders_none?: OrderWhereInput;
  cart_every?: VariantWhereInput;
  cart_some?: VariantWhereInput;
  cart_none?: VariantWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AttributeUpdateManyWithoutProductsInput {
  create?:
    | AttributeCreateWithoutProductsInput[]
    | AttributeCreateWithoutProductsInput;
  delete?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  set?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  disconnect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  update?:
    | AttributeUpdateWithWhereUniqueWithoutProductsInput[]
    | AttributeUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | AttributeUpsertWithWhereUniqueWithoutProductsInput[]
    | AttributeUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  updateMany?:
    | AttributeUpdateManyWithWhereNestedInput[]
    | AttributeUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateManyMutationInput {
  subTotalBeforeTax?: Int;
  subTotal?: Int;
  state?: OrderState;
}

export interface AttributeUpdateWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  data: AttributeUpdateWithoutProductsDataInput;
}

export interface VariantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  optionValues_every?: OptionValueWhereInput;
  optionValues_some?: OptionValueWhereInput;
  optionValues_none?: OptionValueWhereInput;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  availableForSale?: Boolean;
  availableForSale_not?: Boolean;
  sku?: String;
  sku_not?: String;
  sku_in?: String[] | String;
  sku_not_in?: String[] | String;
  sku_lt?: String;
  sku_lte?: String;
  sku_gt?: String;
  sku_gte?: String;
  sku_contains?: String;
  sku_not_contains?: String;
  sku_starts_with?: String;
  sku_not_starts_with?: String;
  sku_ends_with?: String;
  sku_not_ends_with?: String;
  images_every?: ImageWhereInput;
  images_some?: ImageWhereInput;
  images_none?: ImageWhereInput;
  AND?: VariantWhereInput[] | VariantWhereInput;
  OR?: VariantWhereInput[] | VariantWhereInput;
  NOT?: VariantWhereInput[] | VariantWhereInput;
}

export interface AttributeUpdateWithoutProductsDataInput {
  key?: String;
  value?: String;
}

export interface ProductTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ProductTypeWhereInput[] | ProductTypeWhereInput;
  OR?: ProductTypeWhereInput[] | ProductTypeWhereInput;
  NOT?: ProductTypeWhereInput[] | ProductTypeWhereInput;
}

export interface AttributeUpsertWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  update: AttributeUpdateWithoutProductsDataInput;
  create: AttributeCreateWithoutProductsInput;
}

export interface OrderLineItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  unitPrice?: Int;
  unitPrice_not?: Int;
  unitPrice_in?: Int[] | Int;
  unitPrice_not_in?: Int[] | Int;
  unitPrice_lt?: Int;
  unitPrice_lte?: Int;
  unitPrice_gt?: Int;
  unitPrice_gte?: Int;
  sku?: String;
  sku_not?: String;
  sku_in?: String[] | String;
  sku_not_in?: String[] | String;
  sku_lt?: String;
  sku_lte?: String;
  sku_gt?: String;
  sku_gte?: String;
  sku_contains?: String;
  sku_not_contains?: String;
  sku_starts_with?: String;
  sku_not_starts_with?: String;
  sku_ends_with?: String;
  sku_not_ends_with?: String;
  AND?: OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput;
  OR?: OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput;
  NOT?: OrderLineItemScalarWhereInput[] | OrderLineItemScalarWhereInput;
}

export interface AttributeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  OR?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  NOT?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
}

export interface OrderOptionValuesUpdateManyWithWhereNestedInput {
  where: OrderOptionValuesScalarWhereInput;
  data: OrderOptionValuesUpdateManyDataInput;
}

export interface AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput;
  data: AttributeUpdateManyDataInput;
}

export interface OrderOptionValuesUpdateDataInput {
  optionName?: String;
  optionValue?: String;
}

export interface AttributeUpdateManyDataInput {
  key?: String;
  value?: String;
}

export interface OrderOptionValuesUpdateManyInput {
  create?: OrderOptionValuesCreateInput[] | OrderOptionValuesCreateInput;
  update?:
    | OrderOptionValuesUpdateWithWhereUniqueNestedInput[]
    | OrderOptionValuesUpdateWithWhereUniqueNestedInput;
  upsert?:
    | OrderOptionValuesUpsertWithWhereUniqueNestedInput[]
    | OrderOptionValuesUpsertWithWhereUniqueNestedInput;
  delete?:
    | OrderOptionValuesWhereUniqueInput[]
    | OrderOptionValuesWhereUniqueInput;
  connect?:
    | OrderOptionValuesWhereUniqueInput[]
    | OrderOptionValuesWhereUniqueInput;
  set?: OrderOptionValuesWhereUniqueInput[] | OrderOptionValuesWhereUniqueInput;
  disconnect?:
    | OrderOptionValuesWhereUniqueInput[]
    | OrderOptionValuesWhereUniqueInput;
  deleteMany?:
    | OrderOptionValuesScalarWhereInput[]
    | OrderOptionValuesScalarWhereInput;
  updateMany?:
    | OrderOptionValuesUpdateManyWithWhereNestedInput[]
    | OrderOptionValuesUpdateManyWithWhereNestedInput;
}

export interface ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutBrandDataInput;
  create: ProductCreateWithoutBrandInput;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface BrandUpdateManyMutationInput {
  name?: String;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  brand?: BrandWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: ProductTypeWhereInput;
  thumbnail?: ImageWhereInput;
  variants_every?: VariantWhereInput;
  variants_some?: VariantWhereInput;
  variants_none?: VariantWhereInput;
  collections_every?: CollectionWhereInput;
  collections_some?: CollectionWhereInput;
  collections_none?: CollectionWhereInput;
  attributes_every?: AttributeWhereInput;
  attributes_some?: AttributeWhereInput;
  attributes_none?: AttributeWhereInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface CollectionCreateInput {
  name: String;
  rules?: CollectionRuleSetCreateOneInput;
  products?: ProductCreateManyWithoutCollectionsInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductCreateManyWithoutCollectionsInput {
  create?:
    | ProductCreateWithoutCollectionsInput[]
    | ProductCreateWithoutCollectionsInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface UserUpdateDataInput {
  orders?: OrderUpdateManyWithoutCustomerInput;
  cart?: VariantUpdateManyInput;
}

export interface ProductCreateWithoutCollectionsInput {
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface OrderLineItemUpdateWithWhereUniqueNestedInput {
  where: OrderLineItemWhereUniqueInput;
  data: OrderLineItemUpdateDataInput;
}

export interface CollectionUpdateInput {
  name?: String;
  rules?: CollectionRuleSetUpdateOneInput;
  products?: ProductUpdateManyWithoutCollectionsInput;
}

export interface ProductCreateWithoutAttributesInput {
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
}

export interface ProductUpdateManyWithoutCollectionsInput {
  create?:
    | ProductCreateWithoutCollectionsInput[]
    | ProductCreateWithoutCollectionsInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutCollectionsInput[]
    | ProductUpdateWithWhereUniqueWithoutCollectionsInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutCollectionsInput[]
    | ProductUpsertWithWhereUniqueWithoutCollectionsInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductTypeCreateInput {
  name: String;
}

export interface ProductUpdateWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCollectionsDataInput;
}

export interface VariantCreateInput {
  optionValues?: OptionValueCreateManyInput;
  price: Int;
  availableForSale?: Boolean;
  sku?: String;
  images?: ImageCreateManyInput;
}

export interface ProductUpdateWithoutCollectionsDataInput {
  slug?: String;
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface OptionCreateWithoutValuesInput {
  name: String;
  isColor: Boolean;
}

export interface ProductUpsertWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCollectionsDataInput;
  create: ProductCreateWithoutCollectionsInput;
}

export interface CollectionRuleSetCreateOneInput {
  create?: CollectionRuleSetCreateInput;
  connect?: CollectionRuleSetWhereUniqueInput;
}

export interface CollectionUpdateManyMutationInput {
  name?: String;
}

export interface OrderLineItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderLineItemWhereInput;
  AND?:
    | OrderLineItemSubscriptionWhereInput[]
    | OrderLineItemSubscriptionWhereInput;
  OR?:
    | OrderLineItemSubscriptionWhereInput[]
    | OrderLineItemSubscriptionWhereInput;
  NOT?:
    | OrderLineItemSubscriptionWhereInput[]
    | OrderLineItemSubscriptionWhereInput;
}

export interface CollectionRuleUpdateInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface CollectionRuleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: CollectionRuleField;
  field_not?: CollectionRuleField;
  field_in?: CollectionRuleField[] | CollectionRuleField;
  field_not_in?: CollectionRuleField[] | CollectionRuleField;
  relation?: CollectionRuleRelation;
  relation_not?: CollectionRuleRelation;
  relation_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  relation_not_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: CollectionRuleWhereInput[] | CollectionRuleWhereInput;
  OR?: CollectionRuleWhereInput[] | CollectionRuleWhereInput;
  NOT?: CollectionRuleWhereInput[] | CollectionRuleWhereInput;
}

export interface CollectionRuleUpdateManyMutationInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export type CollectionRuleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CollectionRuleSetUpdateInput {
  rules?: CollectionRuleUpdateManyInput;
  appliesDisjunctively?: Boolean;
}

export interface ProductCreateInput {
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface CollectionRuleSetUpdateManyMutationInput {
  appliesDisjunctively?: Boolean;
}

export interface PaymentUpdateInput {
  method?: PaymentMethod;
  amount?: Int;
  state?: PaymentState;
  order?: OrderUpdateOneRequiredWithoutPaymentInput;
  currencyCode?: CurrencyCode;
}

export interface ImageUpdateInput {
  url?: String;
}

export interface OrderLineItemUpdateManyMutationInput {
  quantity?: Int;
  unitPrice?: Int;
  sku?: String;
}

export interface ImageUpdateManyMutationInput {
  url?: String;
}

export interface OptionValueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  option?: OptionWhereInput;
  AND?: OptionValueWhereInput[] | OptionValueWhereInput;
  OR?: OptionValueWhereInput[] | OptionValueWhereInput;
  NOT?: OptionValueWhereInput[] | OptionValueWhereInput;
}

export interface OptionCreateInput {
  name: String;
  isColor: Boolean;
  values?: OptionValueCreateManyWithoutOptionInput;
}

export interface OrderLineItemUpdateManyDataInput {
  quantity?: Int;
  unitPrice?: Int;
  sku?: String;
}

export interface OptionValueCreateManyWithoutOptionInput {
  create?:
    | OptionValueCreateWithoutOptionInput[]
    | OptionValueCreateWithoutOptionInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
}

export type OrderOptionValuesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OptionValueCreateWithoutOptionInput {
  name: String;
}

export interface OrderUpdateManyDataInput {
  subTotalBeforeTax?: Int;
  subTotal?: Int;
  state?: OrderState;
}

export interface OptionUpdateInput {
  name?: String;
  isColor?: Boolean;
  values?: OptionValueUpdateManyWithoutOptionInput;
}

export interface PaymentUpdateWithoutOrderDataInput {
  method?: PaymentMethod;
  amount?: Int;
  state?: PaymentState;
  currencyCode?: CurrencyCode;
}

export interface OptionValueUpdateManyWithoutOptionInput {
  create?:
    | OptionValueCreateWithoutOptionInput[]
    | OptionValueCreateWithoutOptionInput;
  delete?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  set?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  disconnect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  update?:
    | OptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    | OptionValueUpdateWithWhereUniqueWithoutOptionInput;
  upsert?:
    | OptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    | OptionValueUpsertWithWhereUniqueWithoutOptionInput;
  deleteMany?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  updateMany?:
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface OptionValueUpdateWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateWithoutOptionDataInput;
}

export interface BrandCreateWithoutProductsInput {
  name: String;
}

export interface OptionValueUpdateWithoutOptionDataInput {
  name?: String;
}

export interface OptionValueCreateInput {
  name: String;
  option: OptionCreateOneWithoutValuesInput;
}

export interface OptionValueUpsertWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateWithoutOptionDataInput;
  create: OptionValueCreateWithoutOptionInput;
}

export interface ProductTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductTypeWhereInput;
  AND?: ProductTypeSubscriptionWhereInput[] | ProductTypeSubscriptionWhereInput;
  OR?: ProductTypeSubscriptionWhereInput[] | ProductTypeSubscriptionWhereInput;
  NOT?: ProductTypeSubscriptionWhereInput[] | ProductTypeSubscriptionWhereInput;
}

export interface OptionUpdateManyMutationInput {
  name?: String;
  isColor?: Boolean;
}

export type CollectionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OptionValueUpdateInput {
  name?: String;
  option?: OptionUpdateOneRequiredWithoutValuesInput;
}

export interface OrderUpdateWithoutPaymentDataInput {
  items?: OrderLineItemUpdateManyInput;
  customer?: UserUpdateOneRequiredWithoutOrdersInput;
  subTotalBeforeTax?: Int;
  subTotal?: Int;
  state?: OrderState;
}

export interface OptionValueUpdateManyMutationInput {
  name?: String;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  method?: PaymentMethod;
  method_not?: PaymentMethod;
  method_in?: PaymentMethod[] | PaymentMethod;
  method_not_in?: PaymentMethod[] | PaymentMethod;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  state?: PaymentState;
  state_not?: PaymentState;
  state_in?: PaymentState[] | PaymentState;
  state_not_in?: PaymentState[] | PaymentState;
  order?: OrderWhereInput;
  currencyCode?: CurrencyCode;
  currencyCode_not?: CurrencyCode;
  currencyCode_in?: CurrencyCode[] | CurrencyCode;
  currencyCode_not_in?: CurrencyCode[] | CurrencyCode;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface OrderCreateInput {
  items?: OrderLineItemCreateManyInput;
  customer: UserCreateOneWithoutOrdersInput;
  subTotalBeforeTax: Int;
  subTotal: Int;
  payment: PaymentCreateOneWithoutOrderInput;
  state: OrderState;
}

export type OrderLineItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrderLineItemCreateManyInput {
  create?: OrderLineItemCreateInput[] | OrderLineItemCreateInput;
  connect?: OrderLineItemWhereUniqueInput[] | OrderLineItemWhereUniqueInput;
}

export interface OrderUpsertWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutCustomerDataInput;
  create: OrderCreateWithoutCustomerInput;
}

export interface OrderLineItemCreateInput {
  owner?: UserCreateOneInput;
  image: ImageCreateOneInput;
  quantity: Int;
  unitPrice: Int;
  sku?: String;
  orderOptionValues?: OrderOptionValuesCreateManyInput;
}

export interface AttributeCreateInput {
  key: String;
  value: String;
  products?: ProductCreateManyWithoutAttributesInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface CollectionCreateManyWithoutProductsInput {
  create?:
    | CollectionCreateWithoutProductsInput[]
    | CollectionCreateWithoutProductsInput;
  connect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
}

export interface UserCreateInput {
  orders?: OrderCreateManyWithoutCustomerInput;
  cart?: VariantCreateManyInput;
}

export type CollectionRuleSetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrderCreateManyWithoutCustomerInput {
  create?: OrderCreateWithoutCustomerInput[] | OrderCreateWithoutCustomerInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface UserUpdateWithoutOrdersDataInput {
  cart?: VariantUpdateManyInput;
}

export interface OrderOptionValuesCreateManyInput {
  create?: OrderOptionValuesCreateInput[] | OrderOptionValuesCreateInput;
  connect?:
    | OrderOptionValuesWhereUniqueInput[]
    | OrderOptionValuesWhereUniqueInput;
}

export interface PaymentCreateWithoutOrderInput {
  method: PaymentMethod;
  amount: Int;
  state: PaymentState;
  currencyCode: CurrencyCode;
}

export interface PaymentCreateOneWithoutOrderInput {
  create?: PaymentCreateWithoutOrderInput;
  connect?: PaymentWhereUniqueInput;
}

export interface OrderCreateWithoutCustomerInput {
  items?: OrderLineItemCreateManyInput;
  subTotalBeforeTax: Int;
  subTotal: Int;
  payment: PaymentCreateOneWithoutOrderInput;
  state: OrderState;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PaymentCreateInput {
  method: PaymentMethod;
  amount: Int;
  state: PaymentState;
  order: OrderCreateOneWithoutPaymentInput;
  currencyCode: CurrencyCode;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionWhereInput;
  AND?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  OR?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  NOT?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
}

export interface ImageCreateInput {
  url: String;
}

export interface OrderUpdateWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutCustomerDataInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VariantPreviousValues {
  id: ID_Output;
  price: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface VariantPreviousValuesPromise
  extends Promise<VariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
  availableForSale: () => Promise<Boolean>;
  sku: () => Promise<String>;
}

export interface VariantPreviousValuesSubscription
  extends Promise<AsyncIterator<VariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
  availableForSale: () => Promise<AsyncIterator<Boolean>>;
  sku: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRuleConnection {
  pageInfo: PageInfo;
  edges: CollectionRuleEdge[];
}

export interface CollectionRuleConnectionPromise
  extends Promise<CollectionRuleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionRuleEdge>>() => T;
  aggregate: <T = AggregateCollectionRulePromise>() => T;
}

export interface CollectionRuleConnectionSubscription
  extends Promise<AsyncIterator<CollectionRuleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionRuleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionRuleSubscription>() => T;
}

export interface Variant {
  id: ID_Output;
  price: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface VariantPromise extends Promise<Variant>, Fragmentable {
  id: () => Promise<ID_Output>;
  optionValues: <T = FragmentableArray<OptionValue>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  price: () => Promise<Int>;
  availableForSale: () => Promise<Boolean>;
  sku: () => Promise<String>;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VariantSubscription
  extends Promise<AsyncIterator<Variant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionValues: <T = Promise<AsyncIterator<OptionValueSubscription>>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  price: () => Promise<AsyncIterator<Int>>;
  availableForSale: () => Promise<AsyncIterator<Boolean>>;
  sku: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateCollection {
  count: Int;
}

export interface AggregateCollectionPromise
  extends Promise<AggregateCollection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionSubscription
  extends Promise<AsyncIterator<AggregateCollection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Image {
  id: ID_Output;
  url: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface CollectionEdge {
  node: Collection;
  cursor: String;
}

export interface CollectionEdgePromise
  extends Promise<CollectionEdge>,
    Fragmentable {
  node: <T = CollectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionEdgeSubscription
  extends Promise<AsyncIterator<CollectionEdge>>,
    Fragmentable {
  node: <T = CollectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVariant {
  count: Int;
}

export interface AggregateVariantPromise
  extends Promise<AggregateVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVariantSubscription
  extends Promise<AsyncIterator<AggregateVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionConnection {
  pageInfo: PageInfo;
  edges: CollectionEdge[];
}

export interface CollectionConnectionPromise
  extends Promise<CollectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionEdge>>() => T;
  aggregate: <T = AggregateCollectionPromise>() => T;
}

export interface CollectionConnectionSubscription
  extends Promise<AsyncIterator<CollectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionSubscription>() => T;
}

export interface VariantConnection {
  pageInfo: PageInfo;
  edges: VariantEdge[];
}

export interface VariantConnectionPromise
  extends Promise<VariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VariantEdge>>() => T;
  aggregate: <T = AggregateVariantPromise>() => T;
}

export interface VariantConnectionSubscription
  extends Promise<AsyncIterator<VariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVariantSubscription>() => T;
}

export interface Attribute {
  id: ID_Output;
  key: String;
  value: String;
}

export interface AttributePromise extends Promise<Attribute>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AttributeSubscription
  extends Promise<AsyncIterator<Attribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Option {
  id: ID_Output;
  name: String;
  isColor: Boolean;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isColor: () => Promise<Boolean>;
  values: <T = FragmentableArray<OptionValue>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isColor: () => Promise<AsyncIterator<Boolean>>;
  values: <T = Promise<AsyncIterator<OptionValueSubscription>>>(args?: {
    where?: OptionValueWhereInput;
    orderBy?: OptionValueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AttributeSubscriptionPayload {
  mutation: MutationType;
  node: Attribute;
  updatedFields: String[];
  previousValues: AttributePreviousValues;
}

export interface AttributeSubscriptionPayloadPromise
  extends Promise<AttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributePreviousValuesPromise>() => T;
}

export interface AttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributePreviousValuesSubscription>() => T;
}

export interface AggregateProductType {
  count: Int;
}

export interface AggregateProductTypePromise
  extends Promise<AggregateProductType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductTypeSubscription
  extends Promise<AsyncIterator<AggregateProductType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductTypeConnection {
  pageInfo: PageInfo;
  edges: ProductTypeEdge[];
}

export interface ProductTypeConnectionPromise
  extends Promise<ProductTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductTypeEdge>>() => T;
  aggregate: <T = AggregateProductTypePromise>() => T;
}

export interface ProductTypeConnectionSubscription
  extends Promise<AsyncIterator<ProductTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductTypeSubscription>() => T;
}

export interface AttributePreviousValues {
  id: ID_Output;
  key: String;
  value: String;
}

export interface AttributePreviousValuesPromise
  extends Promise<AttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface AttributePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface BrandPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OrderOptionValuesEdge {
  node: OrderOptionValues;
  cursor: String;
}

export interface OrderOptionValuesEdgePromise
  extends Promise<OrderOptionValuesEdge>,
    Fragmentable {
  node: <T = OrderOptionValuesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderOptionValuesEdgeSubscription
  extends Promise<AsyncIterator<OrderOptionValuesEdge>>,
    Fragmentable {
  node: <T = OrderOptionValuesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderLineItem {
  count: Int;
}

export interface AggregateOrderLineItemPromise
  extends Promise<AggregateOrderLineItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderLineItemSubscription
  extends Promise<AsyncIterator<AggregateOrderLineItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionSubscriptionPayload {
  mutation: MutationType;
  node: Collection;
  updatedFields: String[];
  previousValues: CollectionPreviousValues;
}

export interface CollectionSubscriptionPayloadPromise
  extends Promise<CollectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionPreviousValuesPromise>() => T;
}

export interface CollectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionPreviousValuesSubscription>() => T;
}

export interface OrderLineItemConnection {
  pageInfo: PageInfo;
  edges: OrderLineItemEdge[];
}

export interface OrderLineItemConnectionPromise
  extends Promise<OrderLineItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderLineItemEdge>>() => T;
  aggregate: <T = AggregateOrderLineItemPromise>() => T;
}

export interface OrderLineItemConnectionSubscription
  extends Promise<AsyncIterator<OrderLineItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderLineItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderLineItemSubscription>() => T;
}

export interface CollectionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CollectionPreviousValuesPromise
  extends Promise<CollectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CollectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface Payment {
  id: ID_Output;
  method: PaymentMethod;
  amount: Int;
  state: PaymentState;
  currencyCode: CurrencyCode;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  method: () => Promise<PaymentMethod>;
  amount: () => Promise<Int>;
  state: () => Promise<PaymentState>;
  order: <T = OrderPromise>() => T;
  currencyCode: () => Promise<CurrencyCode>;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  method: () => Promise<AsyncIterator<PaymentMethod>>;
  amount: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<PaymentState>>;
  order: <T = OrderSubscription>() => T;
  currencyCode: () => Promise<AsyncIterator<CurrencyCode>>;
}

export interface CollectionRuleSubscriptionPayload {
  mutation: MutationType;
  node: CollectionRule;
  updatedFields: String[];
  previousValues: CollectionRulePreviousValues;
}

export interface CollectionRuleSubscriptionPayloadPromise
  extends Promise<CollectionRuleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionRulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionRulePreviousValuesPromise>() => T;
}

export interface CollectionRuleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionRuleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionRuleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionRulePreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cart: <T = FragmentableArray<Variant>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cart: <T = Promise<AsyncIterator<VariantSubscription>>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CollectionRulePreviousValues {
  id: ID_Output;
  field: CollectionRuleField;
  relation: CollectionRuleRelation;
  value: String;
}

export interface CollectionRulePreviousValuesPromise
  extends Promise<CollectionRulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<CollectionRuleField>;
  relation: () => Promise<CollectionRuleRelation>;
  value: () => Promise<String>;
}

export interface CollectionRulePreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionRulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<CollectionRuleField>>;
  relation: () => Promise<AsyncIterator<CollectionRuleRelation>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface VariantSubscriptionPayload {
  mutation: MutationType;
  node: Variant;
  updatedFields: String[];
  previousValues: VariantPreviousValues;
}

export interface VariantSubscriptionPayloadPromise
  extends Promise<VariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VariantPreviousValuesPromise>() => T;
}

export interface VariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VariantPreviousValuesSubscription>() => T;
}

export interface AggregateAttribute {
  count: Int;
}

export interface AggregateAttributePromise
  extends Promise<AggregateAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeSubscription
  extends Promise<AsyncIterator<AggregateAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CollectionRuleSetSubscriptionPayload {
  mutation: MutationType;
  node: CollectionRuleSet;
  updatedFields: String[];
  previousValues: CollectionRuleSetPreviousValues;
}

export interface CollectionRuleSetSubscriptionPayloadPromise
  extends Promise<CollectionRuleSetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionRuleSetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionRuleSetPreviousValuesPromise>() => T;
}

export interface CollectionRuleSetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionRuleSetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionRuleSetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionRuleSetPreviousValuesSubscription>() => T;
}

export interface AggregateOptionValue {
  count: Int;
}

export interface AggregateOptionValuePromise
  extends Promise<AggregateOptionValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionValueSubscription
  extends Promise<AsyncIterator<AggregateOptionValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionRuleSetPreviousValues {
  id: ID_Output;
  appliesDisjunctively: Boolean;
}

export interface CollectionRuleSetPreviousValuesPromise
  extends Promise<CollectionRuleSetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  appliesDisjunctively: () => Promise<Boolean>;
}

export interface CollectionRuleSetPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionRuleSetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  appliesDisjunctively: () => Promise<AsyncIterator<Boolean>>;
}

export interface OptionValueConnection {
  pageInfo: PageInfo;
  edges: OptionValueEdge[];
}

export interface OptionValueConnectionPromise
  extends Promise<OptionValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionValueEdge>>() => T;
  aggregate: <T = AggregateOptionValuePromise>() => T;
}

export interface OptionValueConnectionSubscription
  extends Promise<AsyncIterator<OptionValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionValueSubscription>() => T;
}

export interface AttributeEdge {
  node: Attribute;
  cursor: String;
}

export interface AttributeEdgePromise
  extends Promise<AttributeEdge>,
    Fragmentable {
  node: <T = AttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeEdgeSubscription
  extends Promise<AsyncIterator<AttributeEdge>>,
    Fragmentable {
  node: <T = AttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImagePreviousValues {
  id: ID_Output;
  url: String;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRuleSetEdge {
  node: CollectionRuleSet;
  cursor: String;
}

export interface CollectionRuleSetEdgePromise
  extends Promise<CollectionRuleSetEdge>,
    Fragmentable {
  node: <T = CollectionRuleSetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionRuleSetEdgeSubscription
  extends Promise<AsyncIterator<CollectionRuleSetEdge>>,
    Fragmentable {
  node: <T = CollectionRuleSetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface AggregateCollectionRule {
  count: Int;
}

export interface AggregateCollectionRulePromise
  extends Promise<AggregateCollectionRule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionRuleSubscription
  extends Promise<AsyncIterator<AggregateCollectionRule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionPreviousValues {
  id: ID_Output;
  name: String;
  isColor: Boolean;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isColor: () => Promise<Boolean>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isColor: () => Promise<AsyncIterator<Boolean>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AttributeConnection {
  pageInfo: PageInfo;
  edges: AttributeEdge[];
}

export interface AttributeConnectionPromise
  extends Promise<AttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeEdge>>() => T;
  aggregate: <T = AggregateAttributePromise>() => T;
}

export interface AttributeConnectionSubscription
  extends Promise<AsyncIterator<AttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeSubscription>() => T;
}

export interface VariantEdge {
  node: Variant;
  cursor: String;
}

export interface VariantEdgePromise extends Promise<VariantEdge>, Fragmentable {
  node: <T = VariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VariantEdgeSubscription
  extends Promise<AsyncIterator<VariantEdge>>,
    Fragmentable {
  node: <T = VariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionValueSubscriptionPayload {
  mutation: MutationType;
  node: OptionValue;
  updatedFields: String[];
  previousValues: OptionValuePreviousValues;
}

export interface OptionValueSubscriptionPayloadPromise
  extends Promise<OptionValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionValuePreviousValuesPromise>() => T;
}

export interface OptionValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionValuePreviousValuesSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionValuePreviousValues {
  id: ID_Output;
  name: String;
}

export interface OptionValuePreviousValuesPromise
  extends Promise<OptionValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionValuePreviousValuesSubscription
  extends Promise<AsyncIterator<OptionValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRule {
  id: ID_Output;
  field: CollectionRuleField;
  relation: CollectionRuleRelation;
  value: String;
}

export interface CollectionRulePromise
  extends Promise<CollectionRule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<CollectionRuleField>;
  relation: () => Promise<CollectionRuleRelation>;
  value: () => Promise<String>;
}

export interface CollectionRuleSubscription
  extends Promise<AsyncIterator<CollectionRule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<CollectionRuleField>>;
  relation: () => Promise<AsyncIterator<CollectionRuleRelation>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface OrderOptionValuesConnection {
  pageInfo: PageInfo;
  edges: OrderOptionValuesEdge[];
}

export interface OrderOptionValuesConnectionPromise
  extends Promise<OrderOptionValuesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderOptionValuesEdge>>() => T;
  aggregate: <T = AggregateOrderOptionValuesPromise>() => T;
}

export interface OrderOptionValuesConnectionSubscription
  extends Promise<AsyncIterator<OrderOptionValuesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderOptionValuesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderOptionValuesSubscription>() => T;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  subTotalBeforeTax: Int;
  subTotal: Int;
  state: OrderState;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  subTotalBeforeTax: () => Promise<Int>;
  subTotal: () => Promise<Int>;
  state: () => Promise<OrderState>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  subTotalBeforeTax: () => Promise<AsyncIterator<Int>>;
  subTotal: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<OrderState>>;
}

export interface OrderOptionValues {
  id: ID_Output;
  optionName: String;
  optionValue: String;
}

export interface OrderOptionValuesPromise
  extends Promise<OrderOptionValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  optionName: () => Promise<String>;
  optionValue: () => Promise<String>;
}

export interface OrderOptionValuesSubscription
  extends Promise<AsyncIterator<OrderOptionValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionName: () => Promise<AsyncIterator<String>>;
  optionValue: () => Promise<AsyncIterator<String>>;
}

export interface Product {
  id: ID_Output;
  slug: String;
  name: String;
  description: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  description: () => Promise<String>;
  type: <T = ProductTypePromise>() => T;
  thumbnail: <T = ImagePromise>() => T;
  variants: <T = FragmentableArray<Variant>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  collections: <T = FragmentableArray<Collection>>(args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  attributes: <T = FragmentableArray<Attribute>>(args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: <T = BrandSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  type: <T = ProductTypeSubscription>() => T;
  thumbnail: <T = ImageSubscription>() => T;
  variants: <T = Promise<AsyncIterator<VariantSubscription>>>(args?: {
    where?: VariantWhereInput;
    orderBy?: VariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  collections: <T = Promise<AsyncIterator<CollectionSubscription>>>(args?: {
    where?: CollectionWhereInput;
    orderBy?: CollectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  attributes: <T = Promise<AsyncIterator<AttributeSubscription>>>(args?: {
    where?: AttributeWhereInput;
    orderBy?: AttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OptionValue {
  id: ID_Output;
  name: String;
}

export interface OptionValuePromise extends Promise<OptionValue>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  option: <T = OptionPromise>() => T;
}

export interface OptionValueSubscription
  extends Promise<AsyncIterator<OptionValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  option: <T = OptionSubscription>() => T;
}

export interface OrderLineItemSubscriptionPayload {
  mutation: MutationType;
  node: OrderLineItem;
  updatedFields: String[];
  previousValues: OrderLineItemPreviousValues;
}

export interface OrderLineItemSubscriptionPayloadPromise
  extends Promise<OrderLineItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderLineItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderLineItemPreviousValuesPromise>() => T;
}

export interface OrderLineItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderLineItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderLineItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderLineItemPreviousValuesSubscription>() => T;
}

export interface OptionValueEdge {
  node: OptionValue;
  cursor: String;
}

export interface OptionValueEdgePromise
  extends Promise<OptionValueEdge>,
    Fragmentable {
  node: <T = OptionValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionValueEdgeSubscription
  extends Promise<AsyncIterator<OptionValueEdge>>,
    Fragmentable {
  node: <T = OptionValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderLineItemPreviousValues {
  id: ID_Output;
  quantity: Int;
  unitPrice: Int;
  sku?: String;
}

export interface OrderLineItemPreviousValuesPromise
  extends Promise<OrderLineItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  unitPrice: () => Promise<Int>;
  sku: () => Promise<String>;
}

export interface OrderLineItemPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderLineItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  unitPrice: () => Promise<AsyncIterator<Int>>;
  sku: () => Promise<AsyncIterator<String>>;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface CollectionRuleSet {
  id: ID_Output;
  appliesDisjunctively: Boolean;
}

export interface CollectionRuleSetPromise
  extends Promise<CollectionRuleSet>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rules: <T = FragmentableArray<CollectionRule>>(args?: {
    where?: CollectionRuleWhereInput;
    orderBy?: CollectionRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appliesDisjunctively: () => Promise<Boolean>;
}

export interface CollectionRuleSetSubscription
  extends Promise<AsyncIterator<CollectionRuleSet>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rules: <T = Promise<AsyncIterator<CollectionRuleSubscription>>>(args?: {
    where?: CollectionRuleWhereInput;
    orderBy?: CollectionRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  appliesDisjunctively: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateCollectionRuleSet {
  count: Int;
}

export interface AggregateCollectionRuleSetPromise
  extends Promise<AggregateCollectionRuleSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionRuleSetSubscription
  extends Promise<AsyncIterator<AggregateCollectionRuleSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderOptionValuesSubscriptionPayload {
  mutation: MutationType;
  node: OrderOptionValues;
  updatedFields: String[];
  previousValues: OrderOptionValuesPreviousValues;
}

export interface OrderOptionValuesSubscriptionPayloadPromise
  extends Promise<OrderOptionValuesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderOptionValuesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderOptionValuesPreviousValuesPromise>() => T;
}

export interface OrderOptionValuesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderOptionValuesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderOptionValuesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderOptionValuesPreviousValuesSubscription>() => T;
}

export interface CollectionRuleEdge {
  node: CollectionRule;
  cursor: String;
}

export interface CollectionRuleEdgePromise
  extends Promise<CollectionRuleEdge>,
    Fragmentable {
  node: <T = CollectionRulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionRuleEdgeSubscription
  extends Promise<AsyncIterator<CollectionRuleEdge>>,
    Fragmentable {
  node: <T = CollectionRuleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderOptionValuesPreviousValues {
  id: ID_Output;
  optionName: String;
  optionValue: String;
}

export interface OrderOptionValuesPreviousValuesPromise
  extends Promise<OrderOptionValuesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  optionName: () => Promise<String>;
  optionValue: () => Promise<String>;
}

export interface OrderOptionValuesPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderOptionValuesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionName: () => Promise<AsyncIterator<String>>;
  optionValue: () => Promise<AsyncIterator<String>>;
}

export interface ProductTypeEdge {
  node: ProductType;
  cursor: String;
}

export interface ProductTypeEdgePromise
  extends Promise<ProductTypeEdge>,
    Fragmentable {
  node: <T = ProductTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductTypeEdgeSubscription
  extends Promise<AsyncIterator<ProductTypeEdge>>,
    Fragmentable {
  node: <T = ProductTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Collection {
  id: ID_Output;
  name: String;
}

export interface CollectionPromise extends Promise<Collection>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  rules: <T = CollectionRuleSetPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CollectionSubscription
  extends Promise<AsyncIterator<Collection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  rules: <T = CollectionRuleSetSubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateOrderOptionValues {
  count: Int;
}

export interface AggregateOrderOptionValuesPromise
  extends Promise<AggregateOrderOptionValues>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderOptionValuesSubscription
  extends Promise<AsyncIterator<AggregateOrderOptionValues>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  method: PaymentMethod;
  amount: Int;
  state: PaymentState;
  currencyCode: CurrencyCode;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  method: () => Promise<PaymentMethod>;
  amount: () => Promise<Int>;
  state: () => Promise<PaymentState>;
  currencyCode: () => Promise<CurrencyCode>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  method: () => Promise<AsyncIterator<PaymentMethod>>;
  amount: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<PaymentState>>;
  currencyCode: () => Promise<AsyncIterator<CurrencyCode>>;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  subTotalBeforeTax: Int;
  subTotal: Int;
  state: OrderState;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  items: <T = FragmentableArray<OrderLineItem>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer: <T = UserPromise>() => T;
  subTotalBeforeTax: () => Promise<Int>;
  subTotal: () => Promise<Int>;
  payment: <T = PaymentPromise>() => T;
  state: () => Promise<OrderState>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  items: <T = Promise<AsyncIterator<OrderLineItemSubscription>>>(args?: {
    where?: OrderLineItemWhereInput;
    orderBy?: OrderLineItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customer: <T = UserSubscription>() => T;
  subTotalBeforeTax: () => Promise<AsyncIterator<Int>>;
  subTotal: () => Promise<AsyncIterator<Int>>;
  payment: <T = PaymentSubscription>() => T;
  state: () => Promise<AsyncIterator<OrderState>>;
}

export interface Brand {
  id: ID_Output;
  name: String;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface OrderLineItemEdge {
  node: OrderLineItem;
  cursor: String;
}

export interface OrderLineItemEdgePromise
  extends Promise<OrderLineItemEdge>,
    Fragmentable {
  node: <T = OrderLineItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderLineItemEdgeSubscription
  extends Promise<AsyncIterator<OrderLineItemEdge>>,
    Fragmentable {
  node: <T = OrderLineItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProductTypePreviousValuesPromise
  extends Promise<ProductTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductTypeSubscriptionPayload {
  mutation: MutationType;
  node: ProductType;
  updatedFields: String[];
  previousValues: ProductTypePreviousValues;
}

export interface ProductTypeSubscriptionPayloadPromise
  extends Promise<ProductTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductTypePreviousValuesPromise>() => T;
}

export interface ProductTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductTypePreviousValuesSubscription>() => T;
}

export interface ProductType {
  id: ID_Output;
  name: String;
}

export interface ProductTypePromise extends Promise<ProductType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductTypeSubscription
  extends Promise<AsyncIterator<ProductType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  description: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface OrderLineItem {
  id: ID_Output;
  quantity: Int;
  unitPrice: Int;
  sku?: String;
}

export interface OrderLineItemPromise
  extends Promise<OrderLineItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  image: <T = ImagePromise>() => T;
  quantity: () => Promise<Int>;
  unitPrice: () => Promise<Int>;
  sku: () => Promise<String>;
  orderOptionValues: <T = FragmentableArray<OrderOptionValues>>(args?: {
    where?: OrderOptionValuesWhereInput;
    orderBy?: OrderOptionValuesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrderLineItemSubscription
  extends Promise<AsyncIterator<OrderLineItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  image: <T = ImageSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  unitPrice: () => Promise<AsyncIterator<Int>>;
  sku: () => Promise<AsyncIterator<String>>;
  orderOptionValues: <
    T = Promise<AsyncIterator<OrderOptionValuesSubscription>>
  >(args?: {
    where?: OrderOptionValuesWhereInput;
    orderBy?: OrderOptionValuesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface CollectionRuleSetConnection {
  pageInfo: PageInfo;
  edges: CollectionRuleSetEdge[];
}

export interface CollectionRuleSetConnectionPromise
  extends Promise<CollectionRuleSetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionRuleSetEdge>>() => T;
  aggregate: <T = AggregateCollectionRuleSetPromise>() => T;
}

export interface CollectionRuleSetConnectionSubscription
  extends Promise<AsyncIterator<CollectionRuleSetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionRuleSetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionRuleSetSubscription>() => T;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Collection",
    embedded: false
  },
  {
    name: "CollectionRuleSet",
    embedded: false
  },
  {
    name: "CollectionRule",
    embedded: false
  },
  {
    name: "CollectionRuleField",
    embedded: false
  },
  {
    name: "CollectionRuleRelation",
    embedded: false
  },
  {
    name: "ProductType",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Attribute",
    embedded: false
  },
  {
    name: "OptionValue",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  },
  {
    name: "Variant",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderLineItem",
    embedded: false
  },
  {
    name: "OrderOptionValues",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "OrderState",
    embedded: false
  },
  {
    name: "PaymentState",
    embedded: false
  },
  {
    name: "CurrencyCode",
    embedded: false
  },
  {
    name: "PaymentMethod",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
