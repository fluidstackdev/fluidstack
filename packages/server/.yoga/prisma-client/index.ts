// Code generated by Prisma (prisma@1.29.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attribute: (where?: AttributeWhereInput) => Promise<boolean>;
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  collection: (where?: CollectionWhereInput) => Promise<boolean>;
  collectionRule: (where?: CollectionRuleWhereInput) => Promise<boolean>;
  collectionRuleSet: (where?: CollectionRuleSetWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  optionValue: (where?: OptionValueWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productType: (where?: ProductTypeWhereInput) => Promise<boolean>;
  variant: (where?: VariantWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  attributes: (
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Attribute>;
  attributesConnection: (
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AttributeConnectionPromise;
  brand: (where: BrandWhereUniqueInput) => BrandPromise;
  brands: (
    args?: {
      where?: BrandWhereInput;
      orderBy?: BrandOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Brand>;
  brandsConnection: (
    args?: {
      where?: BrandWhereInput;
      orderBy?: BrandOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BrandConnectionPromise;
  collection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  collections: (
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Collection>;
  collectionsConnection: (
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CollectionConnectionPromise;
  collectionRule: (
    where: CollectionRuleWhereUniqueInput
  ) => CollectionRulePromise;
  collectionRules: (
    args?: {
      where?: CollectionRuleWhereInput;
      orderBy?: CollectionRuleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CollectionRule>;
  collectionRulesConnection: (
    args?: {
      where?: CollectionRuleWhereInput;
      orderBy?: CollectionRuleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CollectionRuleConnectionPromise;
  collectionRuleSet: (
    where: CollectionRuleSetWhereUniqueInput
  ) => CollectionRuleSetPromise;
  collectionRuleSets: (
    args?: {
      where?: CollectionRuleSetWhereInput;
      orderBy?: CollectionRuleSetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CollectionRuleSet>;
  collectionRuleSetsConnection: (
    args?: {
      where?: CollectionRuleSetWhereInput;
      orderBy?: CollectionRuleSetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CollectionRuleSetConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Image>;
  imagesConnection: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ImageConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionPromise;
  options: (
    args?: {
      where?: OptionWhereInput;
      orderBy?: OptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Option>;
  optionsConnection: (
    args?: {
      where?: OptionWhereInput;
      orderBy?: OptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OptionConnectionPromise;
  optionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  optionValues: (
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<OptionValue>;
  optionValuesConnection: (
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OptionValueConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  productType: (where: ProductTypeWhereUniqueInput) => ProductTypePromise;
  productTypes: (
    args?: {
      where?: ProductTypeWhereInput;
      orderBy?: ProductTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductType>;
  productTypesConnection: (
    args?: {
      where?: ProductTypeWhereInput;
      orderBy?: ProductTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductTypeConnectionPromise;
  variant: (where: VariantWhereUniqueInput) => VariantPromise;
  variants: (
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Variant>;
  variantsConnection: (
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VariantConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttribute: (data: AttributeCreateInput) => AttributePromise;
  updateAttribute: (
    args: { data: AttributeUpdateInput; where: AttributeWhereUniqueInput }
  ) => AttributePromise;
  updateManyAttributes: (
    args: {
      data: AttributeUpdateManyMutationInput;
      where?: AttributeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAttribute: (
    args: {
      where: AttributeWhereUniqueInput;
      create: AttributeCreateInput;
      update: AttributeUpdateInput;
    }
  ) => AttributePromise;
  deleteAttribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  deleteManyAttributes: (where?: AttributeWhereInput) => BatchPayloadPromise;
  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (
    args: { data: BrandUpdateInput; where: BrandWhereUniqueInput }
  ) => BrandPromise;
  updateManyBrands: (
    args: { data: BrandUpdateManyMutationInput; where?: BrandWhereInput }
  ) => BatchPayloadPromise;
  upsertBrand: (
    args: {
      where: BrandWhereUniqueInput;
      create: BrandCreateInput;
      update: BrandUpdateInput;
    }
  ) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCollection: (data: CollectionCreateInput) => CollectionPromise;
  updateCollection: (
    args: { data: CollectionUpdateInput; where: CollectionWhereUniqueInput }
  ) => CollectionPromise;
  updateManyCollections: (
    args: {
      data: CollectionUpdateManyMutationInput;
      where?: CollectionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCollection: (
    args: {
      where: CollectionWhereUniqueInput;
      create: CollectionCreateInput;
      update: CollectionUpdateInput;
    }
  ) => CollectionPromise;
  deleteCollection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  deleteManyCollections: (where?: CollectionWhereInput) => BatchPayloadPromise;
  createCollectionRule: (
    data: CollectionRuleCreateInput
  ) => CollectionRulePromise;
  updateCollectionRule: (
    args: {
      data: CollectionRuleUpdateInput;
      where: CollectionRuleWhereUniqueInput;
    }
  ) => CollectionRulePromise;
  updateManyCollectionRules: (
    args: {
      data: CollectionRuleUpdateManyMutationInput;
      where?: CollectionRuleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCollectionRule: (
    args: {
      where: CollectionRuleWhereUniqueInput;
      create: CollectionRuleCreateInput;
      update: CollectionRuleUpdateInput;
    }
  ) => CollectionRulePromise;
  deleteCollectionRule: (
    where: CollectionRuleWhereUniqueInput
  ) => CollectionRulePromise;
  deleteManyCollectionRules: (
    where?: CollectionRuleWhereInput
  ) => BatchPayloadPromise;
  createCollectionRuleSet: (
    data: CollectionRuleSetCreateInput
  ) => CollectionRuleSetPromise;
  updateCollectionRuleSet: (
    args: {
      data: CollectionRuleSetUpdateInput;
      where: CollectionRuleSetWhereUniqueInput;
    }
  ) => CollectionRuleSetPromise;
  updateManyCollectionRuleSets: (
    args: {
      data: CollectionRuleSetUpdateManyMutationInput;
      where?: CollectionRuleSetWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCollectionRuleSet: (
    args: {
      where: CollectionRuleSetWhereUniqueInput;
      create: CollectionRuleSetCreateInput;
      update: CollectionRuleSetUpdateInput;
    }
  ) => CollectionRuleSetPromise;
  deleteCollectionRuleSet: (
    where: CollectionRuleSetWhereUniqueInput
  ) => CollectionRuleSetPromise;
  deleteManyCollectionRuleSets: (
    where?: CollectionRuleSetWhereInput
  ) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (
    args: { data: ImageUpdateInput; where: ImageWhereUniqueInput }
  ) => ImagePromise;
  updateManyImages: (
    args: { data: ImageUpdateManyMutationInput; where?: ImageWhereInput }
  ) => BatchPayloadPromise;
  upsertImage: (
    args: {
      where: ImageWhereUniqueInput;
      create: ImageCreateInput;
      update: ImageUpdateInput;
    }
  ) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (
    args: { data: OptionUpdateInput; where: OptionWhereUniqueInput }
  ) => OptionPromise;
  updateManyOptions: (
    args: { data: OptionUpdateManyMutationInput; where?: OptionWhereInput }
  ) => BatchPayloadPromise;
  upsertOption: (
    args: {
      where: OptionWhereUniqueInput;
      create: OptionCreateInput;
      update: OptionUpdateInput;
    }
  ) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createOptionValue: (data: OptionValueCreateInput) => OptionValuePromise;
  updateOptionValue: (
    args: { data: OptionValueUpdateInput; where: OptionValueWhereUniqueInput }
  ) => OptionValuePromise;
  updateManyOptionValues: (
    args: {
      data: OptionValueUpdateManyMutationInput;
      where?: OptionValueWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertOptionValue: (
    args: {
      where: OptionValueWhereUniqueInput;
      create: OptionValueCreateInput;
      update: OptionValueUpdateInput;
    }
  ) => OptionValuePromise;
  deleteOptionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  deleteManyOptionValues: (
    where?: OptionValueWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductType: (data: ProductTypeCreateInput) => ProductTypePromise;
  updateProductType: (
    args: { data: ProductTypeUpdateInput; where: ProductTypeWhereUniqueInput }
  ) => ProductTypePromise;
  updateManyProductTypes: (
    args: {
      data: ProductTypeUpdateManyMutationInput;
      where?: ProductTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProductType: (
    args: {
      where: ProductTypeWhereUniqueInput;
      create: ProductTypeCreateInput;
      update: ProductTypeUpdateInput;
    }
  ) => ProductTypePromise;
  deleteProductType: (where: ProductTypeWhereUniqueInput) => ProductTypePromise;
  deleteManyProductTypes: (
    where?: ProductTypeWhereInput
  ) => BatchPayloadPromise;
  createVariant: (data: VariantCreateInput) => VariantPromise;
  updateVariant: (
    args: { data: VariantUpdateInput; where: VariantWhereUniqueInput }
  ) => VariantPromise;
  updateManyVariants: (
    args: { data: VariantUpdateManyMutationInput; where?: VariantWhereInput }
  ) => BatchPayloadPromise;
  upsertVariant: (
    args: {
      where: VariantWhereUniqueInput;
      create: VariantCreateInput;
      update: VariantUpdateInput;
    }
  ) => VariantPromise;
  deleteVariant: (where: VariantWhereUniqueInput) => VariantPromise;
  deleteManyVariants: (where?: VariantWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attribute: (
    where?: AttributeSubscriptionWhereInput
  ) => AttributeSubscriptionPayloadSubscription;
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  collection: (
    where?: CollectionSubscriptionWhereInput
  ) => CollectionSubscriptionPayloadSubscription;
  collectionRule: (
    where?: CollectionRuleSubscriptionWhereInput
  ) => CollectionRuleSubscriptionPayloadSubscription;
  collectionRuleSet: (
    where?: CollectionRuleSetSubscriptionWhereInput
  ) => CollectionRuleSetSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  optionValue: (
    where?: OptionValueSubscriptionWhereInput
  ) => OptionValueSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productType: (
    where?: ProductTypeSubscriptionWhereInput
  ) => ProductTypeSubscriptionPayloadSubscription;
  variant: (
    where?: VariantSubscriptionWhereInput
  ) => VariantSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CollectionRuleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "field_ASC"
  | "field_DESC"
  | "relation_ASC"
  | "relation_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleField = "TYPE" | "TITLE" | "PRICE";

export type CollectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleSetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "appliesDisjunctively_ASC"
  | "appliesDisjunctively_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionRuleRelation =
  | "CONTAINS"
  | "ENDS_WITH"
  | "EQUALS"
  | "GREATER_THAN"
  | "LESS_THAN"
  | "NOT_CONTAINS"
  | "NOT_EQUALS"
  | "STARTS_WITH";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "availableForSale_ASC"
  | "availableForSale_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptionValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "isColor_ASC"
  | "isColor_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface OptionUpdateOneRequiredWithoutValuesInput {
  create?: OptionCreateWithoutValuesInput;
  update?: OptionUpdateWithoutValuesDataInput;
  upsert?: OptionUpsertWithoutValuesInput;
  connect?: OptionWhereUniqueInput;
}

export type AttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface CollectionRuleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: CollectionRuleField;
  field_not?: CollectionRuleField;
  field_in?: CollectionRuleField[] | CollectionRuleField;
  field_not_in?: CollectionRuleField[] | CollectionRuleField;
  relation?: CollectionRuleRelation;
  relation_not?: CollectionRuleRelation;
  relation_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  relation_not_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: CollectionRuleWhereInput[] | CollectionRuleWhereInput;
  OR?: CollectionRuleWhereInput[] | CollectionRuleWhereInput;
  NOT?: CollectionRuleWhereInput[] | CollectionRuleWhereInput;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface AttributeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: AttributeWhereInput[] | AttributeWhereInput;
  OR?: AttributeWhereInput[] | AttributeWhereInput;
  NOT?: AttributeWhereInput[] | AttributeWhereInput;
}

export interface ImageCreateManyInput {
  create?: ImageCreateInput[] | ImageCreateInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
}

export interface AttributeUpsertWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  update: AttributeUpdateWithoutProductsDataInput;
  create: AttributeCreateWithoutProductsInput;
}

export interface CollectionCreateManyWithoutProductsInput {
  create?:
    | CollectionCreateWithoutProductsInput[]
    | CollectionCreateWithoutProductsInput;
  connect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
}

export interface ImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  OR?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  NOT?: ImageScalarWhereInput[] | ImageScalarWhereInput;
}

export interface CollectionCreateWithoutProductsInput {
  name: String;
  rules?: CollectionRuleSetCreateOneInput;
}

export interface ProductTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductTypeWhereInput;
  AND?: ProductTypeSubscriptionWhereInput[] | ProductTypeSubscriptionWhereInput;
  OR?: ProductTypeSubscriptionWhereInput[] | ProductTypeSubscriptionWhereInput;
  NOT?: ProductTypeSubscriptionWhereInput[] | ProductTypeSubscriptionWhereInput;
}

export interface CollectionRuleSetCreateOneInput {
  create?: CollectionRuleSetCreateInput;
  connect?: CollectionRuleSetWhereUniqueInput;
}

export interface OptionValueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionValueWhereInput;
  AND?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
  OR?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
  NOT?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
}

export interface CollectionRuleSetCreateInput {
  rules?: CollectionRuleCreateManyInput;
  appliesDisjunctively: Boolean;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  OR?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  NOT?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface CollectionRuleCreateManyInput {
  create?: CollectionRuleCreateInput[] | CollectionRuleCreateInput;
  connect?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
}

export interface OptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  isColor?: Boolean;
  isColor_not?: Boolean;
  values_every?: OptionValueWhereInput;
  values_some?: OptionValueWhereInput;
  values_none?: OptionValueWhereInput;
  AND?: OptionWhereInput[] | OptionWhereInput;
  OR?: OptionWhereInput[] | OptionWhereInput;
  NOT?: OptionWhereInput[] | OptionWhereInput;
}

export interface CollectionRuleCreateInput {
  field: CollectionRuleField;
  relation: CollectionRuleRelation;
  value: String;
}

export interface CollectionRuleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionRuleWhereInput;
  AND?:
    | CollectionRuleSubscriptionWhereInput[]
    | CollectionRuleSubscriptionWhereInput;
  OR?:
    | CollectionRuleSubscriptionWhereInput[]
    | CollectionRuleSubscriptionWhereInput;
  NOT?:
    | CollectionRuleSubscriptionWhereInput[]
    | CollectionRuleSubscriptionWhereInput;
}

export interface AttributeUpdateInput {
  key?: String;
  value?: String;
  products?: ProductUpdateManyWithoutAttributesInput;
}

export interface VariantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  optionValues_every?: OptionValueWhereInput;
  optionValues_some?: OptionValueWhereInput;
  optionValues_none?: OptionValueWhereInput;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  availableForSale?: Boolean;
  availableForSale_not?: Boolean;
  sku?: String;
  sku_not?: String;
  sku_in?: String[] | String;
  sku_not_in?: String[] | String;
  sku_lt?: String;
  sku_lte?: String;
  sku_gt?: String;
  sku_gte?: String;
  sku_contains?: String;
  sku_not_contains?: String;
  sku_starts_with?: String;
  sku_not_starts_with?: String;
  sku_ends_with?: String;
  sku_not_ends_with?: String;
  images_every?: ImageWhereInput;
  images_some?: ImageWhereInput;
  images_none?: ImageWhereInput;
  AND?: VariantWhereInput[] | VariantWhereInput;
  OR?: VariantWhereInput[] | VariantWhereInput;
  NOT?: VariantWhereInput[] | VariantWhereInput;
}

export interface ProductUpdateManyWithoutAttributesInput {
  create?:
    | ProductCreateWithoutAttributesInput[]
    | ProductCreateWithoutAttributesInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutAttributesInput[]
    | ProductUpdateWithWhereUniqueWithoutAttributesInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutAttributesInput[]
    | ProductUpsertWithWhereUniqueWithoutAttributesInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageWhereInput[] | ImageWhereInput;
  OR?: ImageWhereInput[] | ImageWhereInput;
  NOT?: ImageWhereInput[] | ImageWhereInput;
}

export interface ProductUpdateWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutAttributesDataInput;
}

export interface VariantUpdateManyMutationInput {
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface ProductUpdateWithoutAttributesDataInput {
  slug?: String;
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
}

export interface ProductTypeUpdateManyMutationInput {
  name?: String;
}

export interface BrandUpdateOneRequiredWithoutProductsInput {
  create?: BrandCreateWithoutProductsInput;
  update?: BrandUpdateWithoutProductsDataInput;
  upsert?: BrandUpsertWithoutProductsInput;
  connect?: BrandWhereUniqueInput;
}

export interface ProductTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ProductTypeWhereInput[] | ProductTypeWhereInput;
  OR?: ProductTypeWhereInput[] | ProductTypeWhereInput;
  NOT?: ProductTypeWhereInput[] | ProductTypeWhereInput;
}

export interface BrandUpdateWithoutProductsDataInput {
  name?: String;
}

export interface ProductUpdateManyMutationInput {
  slug?: String;
  name?: String;
  description?: String;
}

export interface BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput;
  create: BrandCreateWithoutProductsInput;
}

export type CollectionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductTypeUpdateOneInput {
  create?: ProductTypeCreateInput;
  update?: ProductTypeUpdateDataInput;
  upsert?: ProductTypeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductTypeWhereUniqueInput;
}

export interface OptionValueUpdateManyMutationInput {
  name?: String;
}

export interface ProductTypeUpdateDataInput {
  name?: String;
}

export type CollectionRuleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductTypeUpsertNestedInput {
  update: ProductTypeUpdateDataInput;
  create: ProductTypeCreateInput;
}

export interface OptionValueUpsertWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateWithoutOptionDataInput;
  create: OptionValueCreateWithoutOptionInput;
}

export interface ImageUpdateOneRequiredInput {
  create?: ImageCreateInput;
  update?: ImageUpdateDataInput;
  upsert?: ImageUpsertNestedInput;
  connect?: ImageWhereUniqueInput;
}

export type CollectionRuleSetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ImageUpdateDataInput {
  url?: String;
}

export interface OptionValueUpdateWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateWithoutOptionDataInput;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface OptionUpdateInput {
  name?: String;
  isColor?: Boolean;
  values?: OptionValueUpdateManyWithoutOptionInput;
}

export interface VariantUpdateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  update?:
    | VariantUpdateWithWhereUniqueNestedInput[]
    | VariantUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VariantUpsertWithWhereUniqueNestedInput[]
    | VariantUpsertWithWhereUniqueNestedInput;
  delete?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  set?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  disconnect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  deleteMany?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  updateMany?:
    | VariantUpdateManyWithWhereNestedInput[]
    | VariantUpdateManyWithWhereNestedInput;
}

export interface OptionValueCreateWithoutOptionInput {
  name: String;
}

export interface VariantUpdateWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  data: VariantUpdateDataInput;
}

export interface OptionCreateInput {
  name: String;
  isColor: Boolean;
  values?: OptionValueCreateManyWithoutOptionInput;
}

export interface VariantUpdateDataInput {
  optionValues?: OptionValueUpdateManyInput;
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
  images?: ImageUpdateManyInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  brand?: BrandWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: ProductTypeWhereInput;
  thumbnail?: ImageWhereInput;
  variants_every?: VariantWhereInput;
  variants_some?: VariantWhereInput;
  variants_none?: VariantWhereInput;
  collections_every?: CollectionWhereInput;
  collections_some?: CollectionWhereInput;
  collections_none?: CollectionWhereInput;
  attributes_every?: AttributeWhereInput;
  attributes_some?: AttributeWhereInput;
  attributes_none?: AttributeWhereInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface OptionValueUpdateManyInput {
  create?: OptionValueCreateInput[] | OptionValueCreateInput;
  update?:
    | OptionValueUpdateWithWhereUniqueNestedInput[]
    | OptionValueUpdateWithWhereUniqueNestedInput;
  upsert?:
    | OptionValueUpsertWithWhereUniqueNestedInput[]
    | OptionValueUpsertWithWhereUniqueNestedInput;
  delete?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  set?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  disconnect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  deleteMany?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  updateMany?:
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput;
}

export interface ImageUpdateInput {
  url?: String;
}

export interface OptionValueUpdateWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateDataInput;
}

export type OptionValueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OptionValueUpdateDataInput {
  name?: String;
  option?: OptionUpdateOneRequiredWithoutValuesInput;
}

export interface CollectionRuleUpdateManyMutationInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutBrandDataInput;
  create: ProductCreateWithoutBrandInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  slug?: String;
}>;

export interface OptionUpdateWithoutValuesDataInput {
  name?: String;
  isColor?: Boolean;
}

export interface ProductUpsertWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCollectionsDataInput;
  create: ProductCreateWithoutCollectionsInput;
}

export interface OptionUpsertWithoutValuesInput {
  update: OptionUpdateWithoutValuesDataInput;
  create: OptionCreateWithoutValuesInput;
}

export type ProductTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OptionValueUpsertWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateDataInput;
  create: OptionValueCreateInput;
}

export interface ProductUpdateManyWithoutCollectionsInput {
  create?:
    | ProductCreateWithoutCollectionsInput[]
    | ProductCreateWithoutCollectionsInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutCollectionsInput[]
    | ProductUpdateWithWhereUniqueWithoutCollectionsInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutCollectionsInput[]
    | ProductUpsertWithWhereUniqueWithoutCollectionsInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface OptionValueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  OR?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  NOT?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
}

export interface ProductCreateWithoutCollectionsInput {
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface OptionValueUpdateManyWithWhereNestedInput {
  where: OptionValueScalarWhereInput;
  data: OptionValueUpdateManyDataInput;
}

export interface ProductCreateManyWithoutCollectionsInput {
  create?:
    | ProductCreateWithoutCollectionsInput[]
    | ProductCreateWithoutCollectionsInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface OptionValueUpdateManyDataInput {
  name?: String;
}

export interface BrandUpdateManyMutationInput {
  name?: String;
}

export interface ImageUpdateManyInput {
  create?: ImageCreateInput[] | ImageCreateInput;
  update?:
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput;
  delete?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  set?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  disconnect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  deleteMany?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  updateMany?:
    | ImageUpdateManyWithWhereNestedInput[]
    | ImageUpdateManyWithWhereNestedInput;
}

export interface AttributeCreateInput {
  key: String;
  value: String;
  products?: ProductCreateManyWithoutAttributesInput;
}

export interface CollectionRuleSetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rules_every?: CollectionRuleWhereInput;
  rules_some?: CollectionRuleWhereInput;
  rules_none?: CollectionRuleWhereInput;
  appliesDisjunctively?: Boolean;
  appliesDisjunctively_not?: Boolean;
  AND?: CollectionRuleSetWhereInput[] | CollectionRuleSetWhereInput;
  OR?: CollectionRuleSetWhereInput[] | CollectionRuleSetWhereInput;
  NOT?: CollectionRuleSetWhereInput[] | CollectionRuleSetWhereInput;
}

export interface ProductCreateWithoutAttributesInput {
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
}

export interface CollectionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rules?: CollectionRuleSetWhereInput;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: CollectionWhereInput[] | CollectionWhereInput;
  OR?: CollectionWhereInput[] | CollectionWhereInput;
  NOT?: CollectionWhereInput[] | CollectionWhereInput;
}

export interface BrandCreateWithoutProductsInput {
  name: String;
}

export interface AttributeUpdateManyDataInput {
  key?: String;
  value?: String;
}

export interface ProductTypeCreateInput {
  name: String;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface ImageCreateInput {
  url: String;
}

export interface ImageUpdateManyDataInput {
  url?: String;
}

export interface VariantCreateInput {
  optionValues?: OptionValueCreateManyInput;
  price: Int;
  availableForSale?: Boolean;
  sku?: String;
  images?: ImageCreateManyInput;
}

export interface VariantUpsertWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  update: VariantUpdateDataInput;
  create: VariantCreateInput;
}

export interface OptionValueCreateInput {
  name: String;
  option: OptionCreateOneWithoutValuesInput;
}

export interface VariantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  availableForSale?: Boolean;
  availableForSale_not?: Boolean;
  sku?: String;
  sku_not?: String;
  sku_in?: String[] | String;
  sku_not_in?: String[] | String;
  sku_lt?: String;
  sku_lte?: String;
  sku_gt?: String;
  sku_gte?: String;
  sku_contains?: String;
  sku_not_contains?: String;
  sku_starts_with?: String;
  sku_not_starts_with?: String;
  sku_ends_with?: String;
  sku_not_ends_with?: String;
  AND?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  OR?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  NOT?: VariantScalarWhereInput[] | VariantScalarWhereInput;
}

export interface OptionCreateWithoutValuesInput {
  name: String;
  isColor: Boolean;
}

export interface VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput;
  data: VariantUpdateManyDataInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface VariantUpdateManyDataInput {
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface CollectionRuleSetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionRuleSetWhereInput;
  AND?:
    | CollectionRuleSetSubscriptionWhereInput[]
    | CollectionRuleSetSubscriptionWhereInput;
  OR?:
    | CollectionRuleSetSubscriptionWhereInput[]
    | CollectionRuleSetSubscriptionWhereInput;
  NOT?:
    | CollectionRuleSetSubscriptionWhereInput[]
    | CollectionRuleSetSubscriptionWhereInput;
}

export interface CollectionUpdateManyWithoutProductsInput {
  create?:
    | CollectionCreateWithoutProductsInput[]
    | CollectionCreateWithoutProductsInput;
  delete?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  connect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  set?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  disconnect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  update?:
    | CollectionUpdateWithWhereUniqueWithoutProductsInput[]
    | CollectionUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | CollectionUpsertWithWhereUniqueWithoutProductsInput[]
    | CollectionUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  updateMany?:
    | CollectionUpdateManyWithWhereNestedInput[]
    | CollectionUpdateManyWithWhereNestedInput;
}

export interface CollectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionWhereInput;
  AND?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
  OR?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
  NOT?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
}

export interface CollectionUpdateWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput;
  data: CollectionUpdateWithoutProductsDataInput;
}

export interface AttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttributeWhereInput;
  AND?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  OR?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  NOT?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
}

export interface CollectionUpdateWithoutProductsDataInput {
  name?: String;
  rules?: CollectionRuleSetUpdateOneInput;
}

export type BrandWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CollectionRuleSetUpdateOneInput {
  create?: CollectionRuleSetCreateInput;
  update?: CollectionRuleSetUpdateDataInput;
  upsert?: CollectionRuleSetUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CollectionRuleSetWhereUniqueInput;
}

export interface ProductUpdateInput {
  slug?: String;
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface CollectionRuleSetUpdateDataInput {
  rules?: CollectionRuleUpdateManyInput;
  appliesDisjunctively?: Boolean;
}

export interface OptionValueUpdateInput {
  name?: String;
  option?: OptionUpdateOneRequiredWithoutValuesInput;
}

export interface CollectionRuleUpdateManyInput {
  create?: CollectionRuleCreateInput[] | CollectionRuleCreateInput;
  update?:
    | CollectionRuleUpdateWithWhereUniqueNestedInput[]
    | CollectionRuleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CollectionRuleUpsertWithWhereUniqueNestedInput[]
    | CollectionRuleUpsertWithWhereUniqueNestedInput;
  delete?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
  connect?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
  set?: CollectionRuleWhereUniqueInput[] | CollectionRuleWhereUniqueInput;
  disconnect?:
    | CollectionRuleWhereUniqueInput[]
    | CollectionRuleWhereUniqueInput;
  deleteMany?:
    | CollectionRuleScalarWhereInput[]
    | CollectionRuleScalarWhereInput;
  updateMany?:
    | CollectionRuleUpdateManyWithWhereNestedInput[]
    | CollectionRuleUpdateManyWithWhereNestedInput;
}

export interface OptionValueUpdateWithoutOptionDataInput {
  name?: String;
}

export interface CollectionRuleUpdateWithWhereUniqueNestedInput {
  where: CollectionRuleWhereUniqueInput;
  data: CollectionRuleUpdateDataInput;
}

export interface OptionValueUpdateManyWithoutOptionInput {
  create?:
    | OptionValueCreateWithoutOptionInput[]
    | OptionValueCreateWithoutOptionInput;
  delete?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  set?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  disconnect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  update?:
    | OptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    | OptionValueUpdateWithWhereUniqueWithoutOptionInput;
  upsert?:
    | OptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    | OptionValueUpsertWithWhereUniqueWithoutOptionInput;
  deleteMany?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  updateMany?:
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput;
}

export interface CollectionRuleUpdateDataInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface OptionValueCreateManyWithoutOptionInput {
  create?:
    | OptionValueCreateWithoutOptionInput[]
    | OptionValueCreateWithoutOptionInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
}

export interface CollectionRuleUpsertWithWhereUniqueNestedInput {
  where: CollectionRuleWhereUniqueInput;
  update: CollectionRuleUpdateDataInput;
  create: CollectionRuleCreateInput;
}

export interface ImageUpdateManyMutationInput {
  url?: String;
}

export interface CollectionRuleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: CollectionRuleField;
  field_not?: CollectionRuleField;
  field_in?: CollectionRuleField[] | CollectionRuleField;
  field_not_in?: CollectionRuleField[] | CollectionRuleField;
  relation?: CollectionRuleRelation;
  relation_not?: CollectionRuleRelation;
  relation_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  relation_not_in?: CollectionRuleRelation[] | CollectionRuleRelation;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: CollectionRuleScalarWhereInput[] | CollectionRuleScalarWhereInput;
  OR?: CollectionRuleScalarWhereInput[] | CollectionRuleScalarWhereInput;
  NOT?: CollectionRuleScalarWhereInput[] | CollectionRuleScalarWhereInput;
}

export interface CollectionRuleSetUpdateInput {
  rules?: CollectionRuleUpdateManyInput;
  appliesDisjunctively?: Boolean;
}

export interface CollectionRuleUpdateManyWithWhereNestedInput {
  where: CollectionRuleScalarWhereInput;
  data: CollectionRuleUpdateManyDataInput;
}

export interface CollectionUpdateManyMutationInput {
  name?: String;
}

export interface CollectionRuleUpdateManyDataInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface ProductUpdateWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCollectionsDataInput;
}

export interface CollectionRuleSetUpsertNestedInput {
  update: CollectionRuleSetUpdateDataInput;
  create: CollectionRuleSetCreateInput;
}

export type VariantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CollectionUpsertWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput;
  update: CollectionUpdateWithoutProductsDataInput;
  create: CollectionCreateWithoutProductsInput;
}

export interface BrandCreateOneWithoutProductsInput {
  create?: BrandCreateWithoutProductsInput;
  connect?: BrandWhereUniqueInput;
}

export interface CollectionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  OR?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  NOT?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
}

export interface ImageCreateOneInput {
  create?: ImageCreateInput;
  connect?: ImageWhereUniqueInput;
}

export interface CollectionUpdateManyWithWhereNestedInput {
  where: CollectionScalarWhereInput;
  data: CollectionUpdateManyDataInput;
}

export interface OptionValueCreateManyInput {
  create?: OptionValueCreateInput[] | OptionValueCreateInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
}

export interface CollectionUpdateManyDataInput {
  name?: String;
}

export interface VariantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VariantWhereInput;
  AND?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  OR?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  NOT?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
}

export interface ProductUpsertWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutAttributesDataInput;
  create: ProductCreateWithoutAttributesInput;
}

export interface OptionValueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  option?: OptionWhereInput;
  AND?: OptionValueWhereInput[] | OptionValueWhereInput;
  OR?: OptionValueWhereInput[] | OptionValueWhereInput;
  NOT?: OptionValueWhereInput[] | OptionValueWhereInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface VariantUpdateInput {
  optionValues?: OptionValueUpdateManyInput;
  price?: Int;
  availableForSale?: Boolean;
  sku?: String;
  images?: ImageUpdateManyInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductCreateInput {
  slug: String;
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface ProductUpdateManyDataInput {
  slug?: String;
  name?: String;
  description?: String;
}

export interface BrandWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: BrandWhereInput[] | BrandWhereInput;
  OR?: BrandWhereInput[] | BrandWhereInput;
  NOT?: BrandWhereInput[] | BrandWhereInput;
}

export interface AttributeUpdateManyMutationInput {
  key?: String;
  value?: String;
}

export type OptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput;
  data: AttributeUpdateManyDataInput;
}

export interface CollectionRuleUpdateInput {
  field?: CollectionRuleField;
  relation?: CollectionRuleRelation;
  value?: String;
}

export interface AttributeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  OR?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  NOT?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
}

export interface CollectionUpdateInput {
  name?: String;
  rules?: CollectionRuleSetUpdateOneInput;
  products?: ProductUpdateManyWithoutCollectionsInput;
}

export interface BrandCreateInput {
  name: String;
  products?: ProductCreateManyWithoutBrandInput;
}

export interface ProductCreateManyWithoutAttributesInput {
  create?:
    | ProductCreateWithoutAttributesInput[]
    | ProductCreateWithoutAttributesInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface VariantCreateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
}

export interface ProductCreateWithoutBrandInput {
  slug: String;
  name: String;
  description: String;
  type?: ProductTypeCreateOneInput;
  thumbnail: ImageCreateOneInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionWhereInput;
  AND?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  OR?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  NOT?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
}

export interface AttributeCreateManyWithoutProductsInput {
  create?:
    | AttributeCreateWithoutProductsInput[]
    | AttributeCreateWithoutProductsInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
}

export interface ProductTypeUpdateInput {
  name?: String;
}

export interface AttributeCreateWithoutProductsInput {
  key: String;
  value: String;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BrandUpdateInput {
  name?: String;
  products?: ProductUpdateManyWithoutBrandInput;
}

export interface ProductUpdateWithoutCollectionsDataInput {
  slug?: String;
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface ProductUpdateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    | ProductUpdateWithWhereUniqueWithoutBrandInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    | ProductUpsertWithWhereUniqueWithoutBrandInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductTypeCreateOneInput {
  create?: ProductTypeCreateInput;
  connect?: ProductTypeWhereUniqueInput;
}

export interface ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutBrandDataInput;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BrandWhereInput;
  AND?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
  OR?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
  NOT?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
}

export interface AttributeUpdateWithoutProductsDataInput {
  key?: String;
  value?: String;
}

export interface AttributeUpdateWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  data: AttributeUpdateWithoutProductsDataInput;
}

export interface AttributeUpdateManyWithoutProductsInput {
  create?:
    | AttributeCreateWithoutProductsInput[]
    | AttributeCreateWithoutProductsInput;
  delete?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  set?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  disconnect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  update?:
    | AttributeUpdateWithWhereUniqueWithoutProductsInput[]
    | AttributeUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | AttributeUpsertWithWhereUniqueWithoutProductsInput[]
    | AttributeUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  updateMany?:
    | AttributeUpdateManyWithWhereNestedInput[]
    | AttributeUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateWithoutBrandDataInput {
  slug?: String;
  name?: String;
  description?: String;
  type?: ProductTypeUpdateOneInput;
  thumbnail?: ImageUpdateOneRequiredInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface OptionUpdateManyMutationInput {
  name?: String;
  isColor?: Boolean;
}

export interface OptionCreateOneWithoutValuesInput {
  create?: OptionCreateWithoutValuesInput;
  connect?: OptionWhereUniqueInput;
}

export interface CollectionCreateInput {
  name: String;
  rules?: CollectionRuleSetCreateOneInput;
  products?: ProductCreateManyWithoutCollectionsInput;
}

export interface CollectionRuleSetUpdateManyMutationInput {
  appliesDisjunctively?: Boolean;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VariantPreviousValues {
  id: ID_Output;
  price: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface VariantPreviousValuesPromise
  extends Promise<VariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
  availableForSale: () => Promise<Boolean>;
  sku: () => Promise<String>;
}

export interface VariantPreviousValuesSubscription
  extends Promise<AsyncIterator<VariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
  availableForSale: () => Promise<AsyncIterator<Boolean>>;
  sku: () => Promise<AsyncIterator<String>>;
}

export interface AttributeEdge {
  node: Attribute;
  cursor: String;
}

export interface AttributeEdgePromise
  extends Promise<AttributeEdge>,
    Fragmentable {
  node: <T = AttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeEdgeSubscription
  extends Promise<AsyncIterator<AttributeEdge>>,
    Fragmentable {
  node: <T = AttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Product {
  id: ID_Output;
  slug: String;
  name: String;
  description: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  description: () => Promise<String>;
  type: <T = ProductTypePromise>() => T;
  thumbnail: <T = ImagePromise>() => T;
  variants: <T = FragmentableArray<Variant>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  collections: <T = FragmentableArray<Collection>>(
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attributes: <T = FragmentableArray<Attribute>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: <T = BrandSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  type: <T = ProductTypeSubscription>() => T;
  thumbnail: <T = ImageSubscription>() => T;
  variants: <T = Promise<AsyncIterator<VariantSubscription>>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  collections: <T = Promise<AsyncIterator<CollectionSubscription>>>(
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attributes: <T = Promise<AsyncIterator<AttributeSubscription>>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Brand {
  id: ID_Output;
  name: String;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AttributeConnection {
  pageInfo: PageInfo;
  edges: AttributeEdge[];
}

export interface AttributeConnectionPromise
  extends Promise<AttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeEdge>>() => T;
  aggregate: <T = AggregateAttributePromise>() => T;
}

export interface AttributeConnectionSubscription
  extends Promise<AsyncIterator<AttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeSubscription>() => T;
}

export interface AggregateVariant {
  count: Int;
}

export interface AggregateVariantPromise
  extends Promise<AggregateVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVariantSubscription
  extends Promise<AsyncIterator<AggregateVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Attribute {
  id: ID_Output;
  key: String;
  value: String;
}

export interface AttributePromise extends Promise<Attribute>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AttributeSubscription
  extends Promise<AsyncIterator<Attribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VariantConnection {
  pageInfo: PageInfo;
  edges: VariantEdge[];
}

export interface VariantConnectionPromise
  extends Promise<VariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VariantEdge>>() => T;
  aggregate: <T = AggregateVariantPromise>() => T;
}

export interface VariantConnectionSubscription
  extends Promise<AsyncIterator<VariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVariantSubscription>() => T;
}

export interface AttributeSubscriptionPayload {
  mutation: MutationType;
  node: Attribute;
  updatedFields: String[];
  previousValues: AttributePreviousValues;
}

export interface AttributeSubscriptionPayloadPromise
  extends Promise<AttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributePreviousValuesPromise>() => T;
}

export interface AttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributePreviousValuesSubscription>() => T;
}

export interface ProductTypeEdge {
  node: ProductType;
  cursor: String;
}

export interface ProductTypeEdgePromise
  extends Promise<ProductTypeEdge>,
    Fragmentable {
  node: <T = ProductTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductTypeEdgeSubscription
  extends Promise<AsyncIterator<ProductTypeEdge>>,
    Fragmentable {
  node: <T = ProductTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductType {
  count: Int;
}

export interface AggregateProductTypePromise
  extends Promise<AggregateProductType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductTypeSubscription
  extends Promise<AsyncIterator<AggregateProductType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductTypeSubscriptionPayload {
  mutation: MutationType;
  node: ProductType;
  updatedFields: String[];
  previousValues: ProductTypePreviousValues;
}

export interface ProductTypeSubscriptionPayloadPromise
  extends Promise<ProductTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductTypePreviousValuesPromise>() => T;
}

export interface ProductTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductTypePreviousValuesSubscription>() => T;
}

export interface ProductTypeConnection {
  pageInfo: PageInfo;
  edges: ProductTypeEdge[];
}

export interface ProductTypeConnectionPromise
  extends Promise<ProductTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductTypeEdge>>() => T;
  aggregate: <T = AggregateProductTypePromise>() => T;
}

export interface ProductTypeConnectionSubscription
  extends Promise<AsyncIterator<ProductTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductTypeSubscription>() => T;
}

export interface AttributePreviousValues {
  id: ID_Output;
  key: String;
  value: String;
}

export interface AttributePreviousValuesPromise
  extends Promise<AttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface AttributePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface CollectionRule {
  id: ID_Output;
  field: CollectionRuleField;
  relation: CollectionRuleRelation;
  value: String;
}

export interface CollectionRulePromise
  extends Promise<CollectionRule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<CollectionRuleField>;
  relation: () => Promise<CollectionRuleRelation>;
  value: () => Promise<String>;
}

export interface CollectionRuleSubscription
  extends Promise<AsyncIterator<CollectionRule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<CollectionRuleField>>;
  relation: () => Promise<AsyncIterator<CollectionRuleRelation>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface OptionValueEdge {
  node: OptionValue;
  cursor: String;
}

export interface OptionValueEdgePromise
  extends Promise<OptionValueEdge>,
    Fragmentable {
  node: <T = OptionValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionValueEdgeSubscription
  extends Promise<AsyncIterator<OptionValueEdge>>,
    Fragmentable {
  node: <T = OptionValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface CollectionRuleSet {
  id: ID_Output;
  appliesDisjunctively: Boolean;
}

export interface CollectionRuleSetPromise
  extends Promise<CollectionRuleSet>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rules: <T = FragmentableArray<CollectionRule>>(
    args?: {
      where?: CollectionRuleWhereInput;
      orderBy?: CollectionRuleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  appliesDisjunctively: () => Promise<Boolean>;
}

export interface CollectionRuleSetSubscription
  extends Promise<AsyncIterator<CollectionRuleSet>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rules: <T = Promise<AsyncIterator<CollectionRuleSubscription>>>(
    args?: {
      where?: CollectionRuleWhereInput;
      orderBy?: CollectionRuleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  appliesDisjunctively: () => Promise<AsyncIterator<Boolean>>;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollectionSubscriptionPayload {
  mutation: MutationType;
  node: Collection;
  updatedFields: String[];
  previousValues: CollectionPreviousValues;
}

export interface CollectionSubscriptionPayloadPromise
  extends Promise<CollectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionPreviousValuesPromise>() => T;
}

export interface CollectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionPreviousValuesSubscription>() => T;
}

export interface AggregateCollectionRuleSet {
  count: Int;
}

export interface AggregateCollectionRuleSetPromise
  extends Promise<AggregateCollectionRuleSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionRuleSetSubscription
  extends Promise<AsyncIterator<AggregateCollectionRuleSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CollectionPreviousValuesPromise
  extends Promise<CollectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CollectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRuleSetConnection {
  pageInfo: PageInfo;
  edges: CollectionRuleSetEdge[];
}

export interface CollectionRuleSetConnectionPromise
  extends Promise<CollectionRuleSetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionRuleSetEdge>>() => T;
  aggregate: <T = AggregateCollectionRuleSetPromise>() => T;
}

export interface CollectionRuleSetConnectionSubscription
  extends Promise<AsyncIterator<CollectionRuleSetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionRuleSetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionRuleSetSubscription>() => T;
}

export interface Collection {
  id: ID_Output;
  name: String;
}

export interface CollectionPromise extends Promise<Collection>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  rules: <T = CollectionRuleSetPromise>() => T;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CollectionSubscription
  extends Promise<AsyncIterator<Collection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  rules: <T = CollectionRuleSetSubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CollectionRuleEdge {
  node: CollectionRule;
  cursor: String;
}

export interface CollectionRuleEdgePromise
  extends Promise<CollectionRuleEdge>,
    Fragmentable {
  node: <T = CollectionRulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionRuleEdgeSubscription
  extends Promise<AsyncIterator<CollectionRuleEdge>>,
    Fragmentable {
  node: <T = CollectionRuleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRuleSubscriptionPayload {
  mutation: MutationType;
  node: CollectionRule;
  updatedFields: String[];
  previousValues: CollectionRulePreviousValues;
}

export interface CollectionRuleSubscriptionPayloadPromise
  extends Promise<CollectionRuleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionRulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionRulePreviousValuesPromise>() => T;
}

export interface CollectionRuleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionRuleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionRuleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionRulePreviousValuesSubscription>() => T;
}

export interface AggregateCollection {
  count: Int;
}

export interface AggregateCollectionPromise
  extends Promise<AggregateCollection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionSubscription
  extends Promise<AsyncIterator<AggregateCollection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionRulePreviousValues {
  id: ID_Output;
  field: CollectionRuleField;
  relation: CollectionRuleRelation;
  value: String;
}

export interface CollectionRulePreviousValuesPromise
  extends Promise<CollectionRulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<CollectionRuleField>;
  relation: () => Promise<CollectionRuleRelation>;
  value: () => Promise<String>;
}

export interface CollectionRulePreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionRulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<CollectionRuleField>>;
  relation: () => Promise<AsyncIterator<CollectionRuleRelation>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface CollectionConnection {
  pageInfo: PageInfo;
  edges: CollectionEdge[];
}

export interface CollectionConnectionPromise
  extends Promise<CollectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionEdge>>() => T;
  aggregate: <T = AggregateCollectionPromise>() => T;
}

export interface CollectionConnectionSubscription
  extends Promise<AsyncIterator<CollectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionSubscription>() => T;
}

export interface Option {
  id: ID_Output;
  name: String;
  isColor: Boolean;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isColor: () => Promise<Boolean>;
  values: <T = FragmentableArray<OptionValue>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isColor: () => Promise<AsyncIterator<Boolean>>;
  values: <T = Promise<AsyncIterator<OptionValueSubscription>>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRuleSetSubscriptionPayload {
  mutation: MutationType;
  node: CollectionRuleSet;
  updatedFields: String[];
  previousValues: CollectionRuleSetPreviousValues;
}

export interface CollectionRuleSetSubscriptionPayloadPromise
  extends Promise<CollectionRuleSetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionRuleSetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionRuleSetPreviousValuesPromise>() => T;
}

export interface CollectionRuleSetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionRuleSetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionRuleSetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionRuleSetPreviousValuesSubscription>() => T;
}

export interface AggregateAttribute {
  count: Int;
}

export interface AggregateAttributePromise
  extends Promise<AggregateAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeSubscription
  extends Promise<AsyncIterator<AggregateAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionRuleSetPreviousValues {
  id: ID_Output;
  appliesDisjunctively: Boolean;
}

export interface CollectionRuleSetPreviousValuesPromise
  extends Promise<CollectionRuleSetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  appliesDisjunctively: () => Promise<Boolean>;
}

export interface CollectionRuleSetPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionRuleSetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  appliesDisjunctively: () => Promise<AsyncIterator<Boolean>>;
}

export interface VariantSubscriptionPayload {
  mutation: MutationType;
  node: Variant;
  updatedFields: String[];
  previousValues: VariantPreviousValues;
}

export interface VariantSubscriptionPayloadPromise
  extends Promise<VariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VariantPreviousValuesPromise>() => T;
}

export interface VariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VariantPreviousValuesSubscription>() => T;
}

export interface OptionValue {
  id: ID_Output;
  name: String;
}

export interface OptionValuePromise extends Promise<OptionValue>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  option: <T = OptionPromise>() => T;
}

export interface OptionValueSubscription
  extends Promise<AsyncIterator<OptionValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  option: <T = OptionSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface OptionValueConnection {
  pageInfo: PageInfo;
  edges: OptionValueEdge[];
}

export interface OptionValueConnectionPromise
  extends Promise<OptionValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionValueEdge>>() => T;
  aggregate: <T = AggregateOptionValuePromise>() => T;
}

export interface OptionValueConnectionSubscription
  extends Promise<AsyncIterator<OptionValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionValueSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  url: String;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductType {
  id: ID_Output;
  name: String;
}

export interface ProductTypePromise extends Promise<ProductType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductTypeSubscription
  extends Promise<AsyncIterator<ProductType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CollectionRuleSetEdge {
  node: CollectionRuleSet;
  cursor: String;
}

export interface CollectionRuleSetEdgePromise
  extends Promise<CollectionRuleSetEdge>,
    Fragmentable {
  node: <T = CollectionRuleSetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionRuleSetEdgeSubscription
  extends Promise<AsyncIterator<CollectionRuleSetEdge>>,
    Fragmentable {
  node: <T = CollectionRuleSetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface CollectionRuleConnection {
  pageInfo: PageInfo;
  edges: CollectionRuleEdge[];
}

export interface CollectionRuleConnectionPromise
  extends Promise<CollectionRuleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionRuleEdge>>() => T;
  aggregate: <T = AggregateCollectionRulePromise>() => T;
}

export interface CollectionRuleConnectionSubscription
  extends Promise<AsyncIterator<CollectionRuleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionRuleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionRuleSubscription>() => T;
}

export interface OptionPreviousValues {
  id: ID_Output;
  name: String;
  isColor: Boolean;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isColor: () => Promise<Boolean>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isColor: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Variant {
  id: ID_Output;
  price: Int;
  availableForSale?: Boolean;
  sku?: String;
}

export interface VariantPromise extends Promise<Variant>, Fragmentable {
  id: () => Promise<ID_Output>;
  optionValues: <T = FragmentableArray<OptionValue>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  price: () => Promise<Int>;
  availableForSale: () => Promise<Boolean>;
  sku: () => Promise<String>;
  images: <T = FragmentableArray<Image>>(
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VariantSubscription
  extends Promise<AsyncIterator<Variant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionValues: <T = Promise<AsyncIterator<OptionValueSubscription>>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  price: () => Promise<AsyncIterator<Int>>;
  availableForSale: () => Promise<AsyncIterator<Boolean>>;
  sku: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface OptionValueSubscriptionPayload {
  mutation: MutationType;
  node: OptionValue;
  updatedFields: String[];
  previousValues: OptionValuePreviousValues;
}

export interface OptionValueSubscriptionPayloadPromise
  extends Promise<OptionValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionValuePreviousValuesPromise>() => T;
}

export interface OptionValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionValuePreviousValuesSubscription>() => T;
}

export interface AggregateOptionValue {
  count: Int;
}

export interface AggregateOptionValuePromise
  extends Promise<AggregateOptionValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionValueSubscription
  extends Promise<AsyncIterator<AggregateOptionValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionValuePreviousValues {
  id: ID_Output;
  name: String;
}

export interface OptionValuePreviousValuesPromise
  extends Promise<OptionValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionValuePreviousValuesSubscription
  extends Promise<AsyncIterator<OptionValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface CollectionEdge {
  node: Collection;
  cursor: String;
}

export interface CollectionEdgePromise
  extends Promise<CollectionEdge>,
    Fragmentable {
  node: <T = CollectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionEdgeSubscription
  extends Promise<AsyncIterator<CollectionEdge>>,
    Fragmentable {
  node: <T = CollectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Image {
  id: ID_Output;
  url: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  description: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProductTypePreviousValuesPromise
  extends Promise<ProductTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface AggregateCollectionRule {
  count: Int;
}

export interface AggregateCollectionRulePromise
  extends Promise<AggregateCollectionRule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionRuleSubscription
  extends Promise<AsyncIterator<AggregateCollectionRule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VariantEdge {
  node: Variant;
  cursor: String;
}

export interface VariantEdgePromise extends Promise<VariantEdge>, Fragmentable {
  node: <T = VariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VariantEdgeSubscription
  extends Promise<AsyncIterator<VariantEdge>>,
    Fragmentable {
  node: <T = VariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Collection",
    embedded: false
  },
  {
    name: "CollectionRuleSet",
    embedded: false
  },
  {
    name: "CollectionRule",
    embedded: false
  },
  {
    name: "CollectionRuleField",
    embedded: false
  },
  {
    name: "CollectionRuleRelation",
    embedded: false
  },
  {
    name: "ProductType",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Attribute",
    embedded: false
  },
  {
    name: "OptionValue",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  },
  {
    name: "Variant",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
