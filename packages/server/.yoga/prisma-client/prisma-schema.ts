// Code generated by Prisma (prisma@1.31.0-beta.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateAttribute {
  count: Int!
}

type AggregateBrand {
  count: Int!
}

type AggregateCollection {
  count: Int!
}

type AggregateCollectionRule {
  count: Int!
}

type AggregateCollectionRuleSet {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateOption {
  count: Int!
}

type AggregateOptionValue {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateOrderLineItem {
  count: Int!
}

type AggregateOrderOptionValues {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductType {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVariant {
  count: Int!
}

type Attribute {
  id: ID!
  key: String!
  value: String!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type AttributeConnection {
  pageInfo: PageInfo!
  edges: [AttributeEdge]!
  aggregate: AggregateAttribute!
}

input AttributeCreateInput {
  key: String!
  value: String!
  products: ProductCreateManyWithoutAttributesInput
}

input AttributeCreateManyWithoutProductsInput {
  create: [AttributeCreateWithoutProductsInput!]
  connect: [AttributeWhereUniqueInput!]
}

input AttributeCreateWithoutProductsInput {
  key: String!
  value: String!
}

type AttributeEdge {
  node: Attribute!
  cursor: String!
}

enum AttributeOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AttributePreviousValues {
  id: ID!
  key: String!
  value: String!
}

input AttributeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [AttributeScalarWhereInput!]
  OR: [AttributeScalarWhereInput!]
  NOT: [AttributeScalarWhereInput!]
}

type AttributeSubscriptionPayload {
  mutation: MutationType!
  node: Attribute
  updatedFields: [String!]
  previousValues: AttributePreviousValues
}

input AttributeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttributeWhereInput
  AND: [AttributeSubscriptionWhereInput!]
  OR: [AttributeSubscriptionWhereInput!]
  NOT: [AttributeSubscriptionWhereInput!]
}

input AttributeUpdateInput {
  key: String
  value: String
  products: ProductUpdateManyWithoutAttributesInput
}

input AttributeUpdateManyDataInput {
  key: String
  value: String
}

input AttributeUpdateManyMutationInput {
  key: String
  value: String
}

input AttributeUpdateManyWithoutProductsInput {
  create: [AttributeCreateWithoutProductsInput!]
  delete: [AttributeWhereUniqueInput!]
  connect: [AttributeWhereUniqueInput!]
  set: [AttributeWhereUniqueInput!]
  disconnect: [AttributeWhereUniqueInput!]
  update: [AttributeUpdateWithWhereUniqueWithoutProductsInput!]
  upsert: [AttributeUpsertWithWhereUniqueWithoutProductsInput!]
  deleteMany: [AttributeScalarWhereInput!]
  updateMany: [AttributeUpdateManyWithWhereNestedInput!]
}

input AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput!
  data: AttributeUpdateManyDataInput!
}

input AttributeUpdateWithoutProductsDataInput {
  key: String
  value: String
}

input AttributeUpdateWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput!
  data: AttributeUpdateWithoutProductsDataInput!
}

input AttributeUpsertWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput!
  update: AttributeUpdateWithoutProductsDataInput!
  create: AttributeCreateWithoutProductsInput!
}

input AttributeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [AttributeWhereInput!]
  OR: [AttributeWhereInput!]
  NOT: [AttributeWhereInput!]
}

input AttributeWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Brand {
  id: ID!
  name: String!
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type BrandConnection {
  pageInfo: PageInfo!
  edges: [BrandEdge]!
  aggregate: AggregateBrand!
}

input BrandCreateInput {
  name: String!
  products: ProductCreateManyWithoutBrandInput
}

input BrandCreateOneWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandCreateWithoutProductsInput {
  name: String!
}

type BrandEdge {
  node: Brand!
  cursor: String!
}

enum BrandOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BrandPreviousValues {
  id: ID!
  name: String!
}

type BrandSubscriptionPayload {
  mutation: MutationType!
  node: Brand
  updatedFields: [String!]
  previousValues: BrandPreviousValues
}

input BrandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BrandWhereInput
  AND: [BrandSubscriptionWhereInput!]
  OR: [BrandSubscriptionWhereInput!]
  NOT: [BrandSubscriptionWhereInput!]
}

input BrandUpdateInput {
  name: String
  products: ProductUpdateManyWithoutBrandInput
}

input BrandUpdateManyMutationInput {
  name: String
}

input BrandUpdateOneRequiredWithoutProductsInput {
  create: BrandCreateWithoutProductsInput
  update: BrandUpdateWithoutProductsDataInput
  upsert: BrandUpsertWithoutProductsInput
  connect: BrandWhereUniqueInput
}

input BrandUpdateWithoutProductsDataInput {
  name: String
}

input BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput!
  create: BrandCreateWithoutProductsInput!
}

input BrandWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [BrandWhereInput!]
  OR: [BrandWhereInput!]
  NOT: [BrandWhereInput!]
}

input BrandWhereUniqueInput {
  id: ID
}

type Collection {
  id: ID!
  name: String!
  rules: CollectionRuleSet
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
}

type CollectionConnection {
  pageInfo: PageInfo!
  edges: [CollectionEdge]!
  aggregate: AggregateCollection!
}

input CollectionCreateInput {
  name: String!
  rules: CollectionRuleSetCreateOneInput
  products: ProductCreateManyWithoutCollectionsInput
}

input CollectionCreateManyWithoutProductsInput {
  create: [CollectionCreateWithoutProductsInput!]
  connect: [CollectionWhereUniqueInput!]
}

input CollectionCreateWithoutProductsInput {
  name: String!
  rules: CollectionRuleSetCreateOneInput
}

type CollectionEdge {
  node: Collection!
  cursor: String!
}

enum CollectionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CollectionPreviousValues {
  id: ID!
  name: String!
}

type CollectionRule {
  id: ID!
  field: CollectionRuleField!
  relation: CollectionRuleRelation!
  value: String!
}

type CollectionRuleConnection {
  pageInfo: PageInfo!
  edges: [CollectionRuleEdge]!
  aggregate: AggregateCollectionRule!
}

input CollectionRuleCreateInput {
  field: CollectionRuleField!
  relation: CollectionRuleRelation!
  value: String!
}

input CollectionRuleCreateManyInput {
  create: [CollectionRuleCreateInput!]
  connect: [CollectionRuleWhereUniqueInput!]
}

type CollectionRuleEdge {
  node: CollectionRule!
  cursor: String!
}

enum CollectionRuleField {
  TYPE
  TITLE
  PRICE
}

enum CollectionRuleOrderByInput {
  id_ASC
  id_DESC
  field_ASC
  field_DESC
  relation_ASC
  relation_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CollectionRulePreviousValues {
  id: ID!
  field: CollectionRuleField!
  relation: CollectionRuleRelation!
  value: String!
}

enum CollectionRuleRelation {
  CONTAINS
  ENDS_WITH
  EQUALS
  GREATER_THAN
  LESS_THAN
  NOT_CONTAINS
  NOT_EQUALS
  STARTS_WITH
}

input CollectionRuleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: CollectionRuleField
  field_not: CollectionRuleField
  field_in: [CollectionRuleField!]
  field_not_in: [CollectionRuleField!]
  relation: CollectionRuleRelation
  relation_not: CollectionRuleRelation
  relation_in: [CollectionRuleRelation!]
  relation_not_in: [CollectionRuleRelation!]
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [CollectionRuleScalarWhereInput!]
  OR: [CollectionRuleScalarWhereInput!]
  NOT: [CollectionRuleScalarWhereInput!]
}

type CollectionRuleSet {
  id: ID!
  rules(where: CollectionRuleWhereInput, orderBy: CollectionRuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CollectionRule!]
  appliesDisjunctively: Boolean!
}

type CollectionRuleSetConnection {
  pageInfo: PageInfo!
  edges: [CollectionRuleSetEdge]!
  aggregate: AggregateCollectionRuleSet!
}

input CollectionRuleSetCreateInput {
  rules: CollectionRuleCreateManyInput
  appliesDisjunctively: Boolean!
}

input CollectionRuleSetCreateOneInput {
  create: CollectionRuleSetCreateInput
  connect: CollectionRuleSetWhereUniqueInput
}

type CollectionRuleSetEdge {
  node: CollectionRuleSet!
  cursor: String!
}

enum CollectionRuleSetOrderByInput {
  id_ASC
  id_DESC
  appliesDisjunctively_ASC
  appliesDisjunctively_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CollectionRuleSetPreviousValues {
  id: ID!
  appliesDisjunctively: Boolean!
}

type CollectionRuleSetSubscriptionPayload {
  mutation: MutationType!
  node: CollectionRuleSet
  updatedFields: [String!]
  previousValues: CollectionRuleSetPreviousValues
}

input CollectionRuleSetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CollectionRuleSetWhereInput
  AND: [CollectionRuleSetSubscriptionWhereInput!]
  OR: [CollectionRuleSetSubscriptionWhereInput!]
  NOT: [CollectionRuleSetSubscriptionWhereInput!]
}

input CollectionRuleSetUpdateDataInput {
  rules: CollectionRuleUpdateManyInput
  appliesDisjunctively: Boolean
}

input CollectionRuleSetUpdateInput {
  rules: CollectionRuleUpdateManyInput
  appliesDisjunctively: Boolean
}

input CollectionRuleSetUpdateManyMutationInput {
  appliesDisjunctively: Boolean
}

input CollectionRuleSetUpdateOneInput {
  create: CollectionRuleSetCreateInput
  update: CollectionRuleSetUpdateDataInput
  upsert: CollectionRuleSetUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CollectionRuleSetWhereUniqueInput
}

input CollectionRuleSetUpsertNestedInput {
  update: CollectionRuleSetUpdateDataInput!
  create: CollectionRuleSetCreateInput!
}

input CollectionRuleSetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rules_every: CollectionRuleWhereInput
  rules_some: CollectionRuleWhereInput
  rules_none: CollectionRuleWhereInput
  appliesDisjunctively: Boolean
  appliesDisjunctively_not: Boolean
  AND: [CollectionRuleSetWhereInput!]
  OR: [CollectionRuleSetWhereInput!]
  NOT: [CollectionRuleSetWhereInput!]
}

input CollectionRuleSetWhereUniqueInput {
  id: ID
}

type CollectionRuleSubscriptionPayload {
  mutation: MutationType!
  node: CollectionRule
  updatedFields: [String!]
  previousValues: CollectionRulePreviousValues
}

input CollectionRuleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CollectionRuleWhereInput
  AND: [CollectionRuleSubscriptionWhereInput!]
  OR: [CollectionRuleSubscriptionWhereInput!]
  NOT: [CollectionRuleSubscriptionWhereInput!]
}

input CollectionRuleUpdateDataInput {
  field: CollectionRuleField
  relation: CollectionRuleRelation
  value: String
}

input CollectionRuleUpdateInput {
  field: CollectionRuleField
  relation: CollectionRuleRelation
  value: String
}

input CollectionRuleUpdateManyDataInput {
  field: CollectionRuleField
  relation: CollectionRuleRelation
  value: String
}

input CollectionRuleUpdateManyInput {
  create: [CollectionRuleCreateInput!]
  update: [CollectionRuleUpdateWithWhereUniqueNestedInput!]
  upsert: [CollectionRuleUpsertWithWhereUniqueNestedInput!]
  delete: [CollectionRuleWhereUniqueInput!]
  connect: [CollectionRuleWhereUniqueInput!]
  set: [CollectionRuleWhereUniqueInput!]
  disconnect: [CollectionRuleWhereUniqueInput!]
  deleteMany: [CollectionRuleScalarWhereInput!]
  updateMany: [CollectionRuleUpdateManyWithWhereNestedInput!]
}

input CollectionRuleUpdateManyMutationInput {
  field: CollectionRuleField
  relation: CollectionRuleRelation
  value: String
}

input CollectionRuleUpdateManyWithWhereNestedInput {
  where: CollectionRuleScalarWhereInput!
  data: CollectionRuleUpdateManyDataInput!
}

input CollectionRuleUpdateWithWhereUniqueNestedInput {
  where: CollectionRuleWhereUniqueInput!
  data: CollectionRuleUpdateDataInput!
}

input CollectionRuleUpsertWithWhereUniqueNestedInput {
  where: CollectionRuleWhereUniqueInput!
  update: CollectionRuleUpdateDataInput!
  create: CollectionRuleCreateInput!
}

input CollectionRuleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  field: CollectionRuleField
  field_not: CollectionRuleField
  field_in: [CollectionRuleField!]
  field_not_in: [CollectionRuleField!]
  relation: CollectionRuleRelation
  relation_not: CollectionRuleRelation
  relation_in: [CollectionRuleRelation!]
  relation_not_in: [CollectionRuleRelation!]
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [CollectionRuleWhereInput!]
  OR: [CollectionRuleWhereInput!]
  NOT: [CollectionRuleWhereInput!]
}

input CollectionRuleWhereUniqueInput {
  id: ID
}

input CollectionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  NOT: [CollectionScalarWhereInput!]
}

type CollectionSubscriptionPayload {
  mutation: MutationType!
  node: Collection
  updatedFields: [String!]
  previousValues: CollectionPreviousValues
}

input CollectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CollectionWhereInput
  AND: [CollectionSubscriptionWhereInput!]
  OR: [CollectionSubscriptionWhereInput!]
  NOT: [CollectionSubscriptionWhereInput!]
}

input CollectionUpdateInput {
  name: String
  rules: CollectionRuleSetUpdateOneInput
  products: ProductUpdateManyWithoutCollectionsInput
}

input CollectionUpdateManyDataInput {
  name: String
}

input CollectionUpdateManyMutationInput {
  name: String
}

input CollectionUpdateManyWithoutProductsInput {
  create: [CollectionCreateWithoutProductsInput!]
  delete: [CollectionWhereUniqueInput!]
  connect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  disconnect: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutProductsInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutProductsInput!]
  deleteMany: [CollectionScalarWhereInput!]
  updateMany: [CollectionUpdateManyWithWhereNestedInput!]
}

input CollectionUpdateManyWithWhereNestedInput {
  where: CollectionScalarWhereInput!
  data: CollectionUpdateManyDataInput!
}

input CollectionUpdateWithoutProductsDataInput {
  name: String
  rules: CollectionRuleSetUpdateOneInput
}

input CollectionUpdateWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput!
  data: CollectionUpdateWithoutProductsDataInput!
}

input CollectionUpsertWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput!
  update: CollectionUpdateWithoutProductsDataInput!
  create: CollectionCreateWithoutProductsInput!
}

input CollectionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rules: CollectionRuleSetWhereInput
  products_every: ProductWhereInput
  products_some: ProductWhereInput
  products_none: ProductWhereInput
  AND: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  NOT: [CollectionWhereInput!]
}

input CollectionWhereUniqueInput {
  id: ID
}

enum CurrencyCode {
  EUR
  USD
}

scalar DateTime

type Image {
  id: ID!
  url: String!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  url: String!
}

input ImageCreateManyInput {
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

input ImageCreateOneInput {
  create: ImageCreateInput
  connect: ImageWhereUniqueInput
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImagePreviousValues {
  id: ID!
  url: String!
}

input ImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  NOT: [ImageScalarWhereInput!]
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  url: String
}

input ImageUpdateInput {
  url: String
}

input ImageUpdateManyDataInput {
  url: String
}

input ImageUpdateManyInput {
  create: [ImageCreateInput!]
  update: [ImageUpdateWithWhereUniqueNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueNestedInput!]
  delete: [ImageWhereUniqueInput!]
  connect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  disconnect: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
}

input ImageUpdateManyMutationInput {
  url: String
}

input ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput!
  data: ImageUpdateManyDataInput!
}

input ImageUpdateOneRequiredInput {
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
  connect: ImageWhereUniqueInput
}

input ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  data: ImageUpdateDataInput!
}

input ImageUpsertNestedInput {
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAttribute(data: AttributeCreateInput!): Attribute!
  updateAttribute(data: AttributeUpdateInput!, where: AttributeWhereUniqueInput!): Attribute
  updateManyAttributes(data: AttributeUpdateManyMutationInput!, where: AttributeWhereInput): BatchPayload!
  upsertAttribute(where: AttributeWhereUniqueInput!, create: AttributeCreateInput!, update: AttributeUpdateInput!): Attribute!
  deleteAttribute(where: AttributeWhereUniqueInput!): Attribute
  deleteManyAttributes(where: AttributeWhereInput): BatchPayload!
  createBrand(data: BrandCreateInput!): Brand!
  updateBrand(data: BrandUpdateInput!, where: BrandWhereUniqueInput!): Brand
  updateManyBrands(data: BrandUpdateManyMutationInput!, where: BrandWhereInput): BatchPayload!
  upsertBrand(where: BrandWhereUniqueInput!, create: BrandCreateInput!, update: BrandUpdateInput!): Brand!
  deleteBrand(where: BrandWhereUniqueInput!): Brand
  deleteManyBrands(where: BrandWhereInput): BatchPayload!
  createCollection(data: CollectionCreateInput!): Collection!
  updateCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection
  updateManyCollections(data: CollectionUpdateManyMutationInput!, where: CollectionWhereInput): BatchPayload!
  upsertCollection(where: CollectionWhereUniqueInput!, create: CollectionCreateInput!, update: CollectionUpdateInput!): Collection!
  deleteCollection(where: CollectionWhereUniqueInput!): Collection
  deleteManyCollections(where: CollectionWhereInput): BatchPayload!
  createCollectionRule(data: CollectionRuleCreateInput!): CollectionRule!
  updateCollectionRule(data: CollectionRuleUpdateInput!, where: CollectionRuleWhereUniqueInput!): CollectionRule
  updateManyCollectionRules(data: CollectionRuleUpdateManyMutationInput!, where: CollectionRuleWhereInput): BatchPayload!
  upsertCollectionRule(where: CollectionRuleWhereUniqueInput!, create: CollectionRuleCreateInput!, update: CollectionRuleUpdateInput!): CollectionRule!
  deleteCollectionRule(where: CollectionRuleWhereUniqueInput!): CollectionRule
  deleteManyCollectionRules(where: CollectionRuleWhereInput): BatchPayload!
  createCollectionRuleSet(data: CollectionRuleSetCreateInput!): CollectionRuleSet!
  updateCollectionRuleSet(data: CollectionRuleSetUpdateInput!, where: CollectionRuleSetWhereUniqueInput!): CollectionRuleSet
  updateManyCollectionRuleSets(data: CollectionRuleSetUpdateManyMutationInput!, where: CollectionRuleSetWhereInput): BatchPayload!
  upsertCollectionRuleSet(where: CollectionRuleSetWhereUniqueInput!, create: CollectionRuleSetCreateInput!, update: CollectionRuleSetUpdateInput!): CollectionRuleSet!
  deleteCollectionRuleSet(where: CollectionRuleSetWhereUniqueInput!): CollectionRuleSet
  deleteManyCollectionRuleSets(where: CollectionRuleSetWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createOption(data: OptionCreateInput!): Option!
  updateOption(data: OptionUpdateInput!, where: OptionWhereUniqueInput!): Option
  updateManyOptions(data: OptionUpdateManyMutationInput!, where: OptionWhereInput): BatchPayload!
  upsertOption(where: OptionWhereUniqueInput!, create: OptionCreateInput!, update: OptionUpdateInput!): Option!
  deleteOption(where: OptionWhereUniqueInput!): Option
  deleteManyOptions(where: OptionWhereInput): BatchPayload!
  createOptionValue(data: OptionValueCreateInput!): OptionValue!
  updateOptionValue(data: OptionValueUpdateInput!, where: OptionValueWhereUniqueInput!): OptionValue
  updateManyOptionValues(data: OptionValueUpdateManyMutationInput!, where: OptionValueWhereInput): BatchPayload!
  upsertOptionValue(where: OptionValueWhereUniqueInput!, create: OptionValueCreateInput!, update: OptionValueUpdateInput!): OptionValue!
  deleteOptionValue(where: OptionValueWhereUniqueInput!): OptionValue
  deleteManyOptionValues(where: OptionValueWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createOrderLineItem(data: OrderLineItemCreateInput!): OrderLineItem!
  updateOrderLineItem(data: OrderLineItemUpdateInput!, where: OrderLineItemWhereUniqueInput!): OrderLineItem
  updateManyOrderLineItems(data: OrderLineItemUpdateManyMutationInput!, where: OrderLineItemWhereInput): BatchPayload!
  upsertOrderLineItem(where: OrderLineItemWhereUniqueInput!, create: OrderLineItemCreateInput!, update: OrderLineItemUpdateInput!): OrderLineItem!
  deleteOrderLineItem(where: OrderLineItemWhereUniqueInput!): OrderLineItem
  deleteManyOrderLineItems(where: OrderLineItemWhereInput): BatchPayload!
  createOrderOptionValues(data: OrderOptionValuesCreateInput!): OrderOptionValues!
  updateOrderOptionValues(data: OrderOptionValuesUpdateInput!, where: OrderOptionValuesWhereUniqueInput!): OrderOptionValues
  updateManyOrderOptionValueses(data: OrderOptionValuesUpdateManyMutationInput!, where: OrderOptionValuesWhereInput): BatchPayload!
  upsertOrderOptionValues(where: OrderOptionValuesWhereUniqueInput!, create: OrderOptionValuesCreateInput!, update: OrderOptionValuesUpdateInput!): OrderOptionValues!
  deleteOrderOptionValues(where: OrderOptionValuesWhereUniqueInput!): OrderOptionValues
  deleteManyOrderOptionValueses(where: OrderOptionValuesWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductType(data: ProductTypeCreateInput!): ProductType!
  updateProductType(data: ProductTypeUpdateInput!, where: ProductTypeWhereUniqueInput!): ProductType
  updateManyProductTypes(data: ProductTypeUpdateManyMutationInput!, where: ProductTypeWhereInput): BatchPayload!
  upsertProductType(where: ProductTypeWhereUniqueInput!, create: ProductTypeCreateInput!, update: ProductTypeUpdateInput!): ProductType!
  deleteProductType(where: ProductTypeWhereUniqueInput!): ProductType
  deleteManyProductTypes(where: ProductTypeWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVariant(data: VariantCreateInput!): Variant!
  updateVariant(data: VariantUpdateInput!, where: VariantWhereUniqueInput!): Variant
  updateManyVariants(data: VariantUpdateManyMutationInput!, where: VariantWhereInput): BatchPayload!
  upsertVariant(where: VariantWhereUniqueInput!, create: VariantCreateInput!, update: VariantUpdateInput!): Variant!
  deleteVariant(where: VariantWhereUniqueInput!): Variant
  deleteManyVariants(where: VariantWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Option {
  id: ID!
  name: String!
  isColor: Boolean!
  values(where: OptionValueWhereInput, orderBy: OptionValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OptionValue!]
}

type OptionConnection {
  pageInfo: PageInfo!
  edges: [OptionEdge]!
  aggregate: AggregateOption!
}

input OptionCreateInput {
  name: String!
  isColor: Boolean!
  values: OptionValueCreateManyWithoutOptionInput
}

input OptionCreateOneWithoutValuesInput {
  create: OptionCreateWithoutValuesInput
  connect: OptionWhereUniqueInput
}

input OptionCreateWithoutValuesInput {
  name: String!
  isColor: Boolean!
}

type OptionEdge {
  node: Option!
  cursor: String!
}

enum OptionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  isColor_ASC
  isColor_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OptionPreviousValues {
  id: ID!
  name: String!
  isColor: Boolean!
}

type OptionSubscriptionPayload {
  mutation: MutationType!
  node: Option
  updatedFields: [String!]
  previousValues: OptionPreviousValues
}

input OptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OptionWhereInput
  AND: [OptionSubscriptionWhereInput!]
  OR: [OptionSubscriptionWhereInput!]
  NOT: [OptionSubscriptionWhereInput!]
}

input OptionUpdateInput {
  name: String
  isColor: Boolean
  values: OptionValueUpdateManyWithoutOptionInput
}

input OptionUpdateManyMutationInput {
  name: String
  isColor: Boolean
}

input OptionUpdateOneRequiredWithoutValuesInput {
  create: OptionCreateWithoutValuesInput
  update: OptionUpdateWithoutValuesDataInput
  upsert: OptionUpsertWithoutValuesInput
  connect: OptionWhereUniqueInput
}

input OptionUpdateWithoutValuesDataInput {
  name: String
  isColor: Boolean
}

input OptionUpsertWithoutValuesInput {
  update: OptionUpdateWithoutValuesDataInput!
  create: OptionCreateWithoutValuesInput!
}

type OptionValue {
  id: ID!
  name: String!
  option: Option!
}

type OptionValueConnection {
  pageInfo: PageInfo!
  edges: [OptionValueEdge]!
  aggregate: AggregateOptionValue!
}

input OptionValueCreateInput {
  name: String!
  option: OptionCreateOneWithoutValuesInput!
}

input OptionValueCreateManyInput {
  create: [OptionValueCreateInput!]
  connect: [OptionValueWhereUniqueInput!]
}

input OptionValueCreateManyWithoutOptionInput {
  create: [OptionValueCreateWithoutOptionInput!]
  connect: [OptionValueWhereUniqueInput!]
}

input OptionValueCreateWithoutOptionInput {
  name: String!
}

type OptionValueEdge {
  node: OptionValue!
  cursor: String!
}

enum OptionValueOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OptionValuePreviousValues {
  id: ID!
  name: String!
}

input OptionValueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [OptionValueScalarWhereInput!]
  OR: [OptionValueScalarWhereInput!]
  NOT: [OptionValueScalarWhereInput!]
}

type OptionValueSubscriptionPayload {
  mutation: MutationType!
  node: OptionValue
  updatedFields: [String!]
  previousValues: OptionValuePreviousValues
}

input OptionValueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OptionValueWhereInput
  AND: [OptionValueSubscriptionWhereInput!]
  OR: [OptionValueSubscriptionWhereInput!]
  NOT: [OptionValueSubscriptionWhereInput!]
}

input OptionValueUpdateDataInput {
  name: String
  option: OptionUpdateOneRequiredWithoutValuesInput
}

input OptionValueUpdateInput {
  name: String
  option: OptionUpdateOneRequiredWithoutValuesInput
}

input OptionValueUpdateManyDataInput {
  name: String
}

input OptionValueUpdateManyInput {
  create: [OptionValueCreateInput!]
  update: [OptionValueUpdateWithWhereUniqueNestedInput!]
  upsert: [OptionValueUpsertWithWhereUniqueNestedInput!]
  delete: [OptionValueWhereUniqueInput!]
  connect: [OptionValueWhereUniqueInput!]
  set: [OptionValueWhereUniqueInput!]
  disconnect: [OptionValueWhereUniqueInput!]
  deleteMany: [OptionValueScalarWhereInput!]
  updateMany: [OptionValueUpdateManyWithWhereNestedInput!]
}

input OptionValueUpdateManyMutationInput {
  name: String
}

input OptionValueUpdateManyWithoutOptionInput {
  create: [OptionValueCreateWithoutOptionInput!]
  delete: [OptionValueWhereUniqueInput!]
  connect: [OptionValueWhereUniqueInput!]
  set: [OptionValueWhereUniqueInput!]
  disconnect: [OptionValueWhereUniqueInput!]
  update: [OptionValueUpdateWithWhereUniqueWithoutOptionInput!]
  upsert: [OptionValueUpsertWithWhereUniqueWithoutOptionInput!]
  deleteMany: [OptionValueScalarWhereInput!]
  updateMany: [OptionValueUpdateManyWithWhereNestedInput!]
}

input OptionValueUpdateManyWithWhereNestedInput {
  where: OptionValueScalarWhereInput!
  data: OptionValueUpdateManyDataInput!
}

input OptionValueUpdateWithoutOptionDataInput {
  name: String
}

input OptionValueUpdateWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput!
  data: OptionValueUpdateDataInput!
}

input OptionValueUpdateWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput!
  data: OptionValueUpdateWithoutOptionDataInput!
}

input OptionValueUpsertWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput!
  update: OptionValueUpdateDataInput!
  create: OptionValueCreateInput!
}

input OptionValueUpsertWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput!
  update: OptionValueUpdateWithoutOptionDataInput!
  create: OptionValueCreateWithoutOptionInput!
}

input OptionValueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  option: OptionWhereInput
  AND: [OptionValueWhereInput!]
  OR: [OptionValueWhereInput!]
  NOT: [OptionValueWhereInput!]
}

input OptionValueWhereUniqueInput {
  id: ID
}

input OptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isColor: Boolean
  isColor_not: Boolean
  values_every: OptionValueWhereInput
  values_some: OptionValueWhereInput
  values_none: OptionValueWhereInput
  AND: [OptionWhereInput!]
  OR: [OptionWhereInput!]
  NOT: [OptionWhereInput!]
}

input OptionWhereUniqueInput {
  id: ID
  name: String
}

type Order {
  id: ID!
  createdAt: DateTime!
  items(where: OrderLineItemWhereInput, orderBy: OrderLineItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderLineItem!]
  customer: User!
  subTotalBeforeTax: Int!
  subTotal: Int!
  payment: Payment!
  state: OrderState!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  items: OrderLineItemCreateManyInput
  customer: UserCreateOneWithoutOrdersInput!
  subTotalBeforeTax: Int!
  subTotal: Int!
  payment: PaymentCreateOneWithoutOrderInput!
  state: OrderState!
}

input OrderCreateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutCustomerInput {
  items: OrderLineItemCreateManyInput
  subTotalBeforeTax: Int!
  subTotal: Int!
  payment: PaymentCreateOneWithoutOrderInput!
  state: OrderState!
}

input OrderCreateWithoutPaymentInput {
  items: OrderLineItemCreateManyInput
  customer: UserCreateOneWithoutOrdersInput!
  subTotalBeforeTax: Int!
  subTotal: Int!
  state: OrderState!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

type OrderLineItem {
  id: ID!
  owner: User
  image: Image!
  quantity: Int!
  unitPrice: Int!
  sku: String
  orderOptionValues(where: OrderOptionValuesWhereInput, orderBy: OrderOptionValuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderOptionValues!]
}

type OrderLineItemConnection {
  pageInfo: PageInfo!
  edges: [OrderLineItemEdge]!
  aggregate: AggregateOrderLineItem!
}

input OrderLineItemCreateInput {
  owner: UserCreateOneInput
  image: ImageCreateOneInput!
  quantity: Int!
  unitPrice: Int!
  sku: String
  orderOptionValues: OrderOptionValuesCreateManyInput
}

input OrderLineItemCreateManyInput {
  create: [OrderLineItemCreateInput!]
  connect: [OrderLineItemWhereUniqueInput!]
}

type OrderLineItemEdge {
  node: OrderLineItem!
  cursor: String!
}

enum OrderLineItemOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  unitPrice_ASC
  unitPrice_DESC
  sku_ASC
  sku_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrderLineItemPreviousValues {
  id: ID!
  quantity: Int!
  unitPrice: Int!
  sku: String
}

input OrderLineItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  unitPrice: Int
  unitPrice_not: Int
  unitPrice_in: [Int!]
  unitPrice_not_in: [Int!]
  unitPrice_lt: Int
  unitPrice_lte: Int
  unitPrice_gt: Int
  unitPrice_gte: Int
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  AND: [OrderLineItemScalarWhereInput!]
  OR: [OrderLineItemScalarWhereInput!]
  NOT: [OrderLineItemScalarWhereInput!]
}

type OrderLineItemSubscriptionPayload {
  mutation: MutationType!
  node: OrderLineItem
  updatedFields: [String!]
  previousValues: OrderLineItemPreviousValues
}

input OrderLineItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderLineItemWhereInput
  AND: [OrderLineItemSubscriptionWhereInput!]
  OR: [OrderLineItemSubscriptionWhereInput!]
  NOT: [OrderLineItemSubscriptionWhereInput!]
}

input OrderLineItemUpdateDataInput {
  owner: UserUpdateOneInput
  image: ImageUpdateOneRequiredInput
  quantity: Int
  unitPrice: Int
  sku: String
  orderOptionValues: OrderOptionValuesUpdateManyInput
}

input OrderLineItemUpdateInput {
  owner: UserUpdateOneInput
  image: ImageUpdateOneRequiredInput
  quantity: Int
  unitPrice: Int
  sku: String
  orderOptionValues: OrderOptionValuesUpdateManyInput
}

input OrderLineItemUpdateManyDataInput {
  quantity: Int
  unitPrice: Int
  sku: String
}

input OrderLineItemUpdateManyInput {
  create: [OrderLineItemCreateInput!]
  update: [OrderLineItemUpdateWithWhereUniqueNestedInput!]
  upsert: [OrderLineItemUpsertWithWhereUniqueNestedInput!]
  delete: [OrderLineItemWhereUniqueInput!]
  connect: [OrderLineItemWhereUniqueInput!]
  set: [OrderLineItemWhereUniqueInput!]
  disconnect: [OrderLineItemWhereUniqueInput!]
  deleteMany: [OrderLineItemScalarWhereInput!]
  updateMany: [OrderLineItemUpdateManyWithWhereNestedInput!]
}

input OrderLineItemUpdateManyMutationInput {
  quantity: Int
  unitPrice: Int
  sku: String
}

input OrderLineItemUpdateManyWithWhereNestedInput {
  where: OrderLineItemScalarWhereInput!
  data: OrderLineItemUpdateManyDataInput!
}

input OrderLineItemUpdateWithWhereUniqueNestedInput {
  where: OrderLineItemWhereUniqueInput!
  data: OrderLineItemUpdateDataInput!
}

input OrderLineItemUpsertWithWhereUniqueNestedInput {
  where: OrderLineItemWhereUniqueInput!
  update: OrderLineItemUpdateDataInput!
  create: OrderLineItemCreateInput!
}

input OrderLineItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  image: ImageWhereInput
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  unitPrice: Int
  unitPrice_not: Int
  unitPrice_in: [Int!]
  unitPrice_not_in: [Int!]
  unitPrice_lt: Int
  unitPrice_lte: Int
  unitPrice_gt: Int
  unitPrice_gte: Int
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  orderOptionValues_every: OrderOptionValuesWhereInput
  orderOptionValues_some: OrderOptionValuesWhereInput
  orderOptionValues_none: OrderOptionValuesWhereInput
  AND: [OrderLineItemWhereInput!]
  OR: [OrderLineItemWhereInput!]
  NOT: [OrderLineItemWhereInput!]
}

input OrderLineItemWhereUniqueInput {
  id: ID
}

type OrderOptionValues {
  id: ID!
  optionName: String!
  optionValue: String!
}

type OrderOptionValuesConnection {
  pageInfo: PageInfo!
  edges: [OrderOptionValuesEdge]!
  aggregate: AggregateOrderOptionValues!
}

input OrderOptionValuesCreateInput {
  optionName: String!
  optionValue: String!
}

input OrderOptionValuesCreateManyInput {
  create: [OrderOptionValuesCreateInput!]
  connect: [OrderOptionValuesWhereUniqueInput!]
}

type OrderOptionValuesEdge {
  node: OrderOptionValues!
  cursor: String!
}

enum OrderOptionValuesOrderByInput {
  id_ASC
  id_DESC
  optionName_ASC
  optionName_DESC
  optionValue_ASC
  optionValue_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrderOptionValuesPreviousValues {
  id: ID!
  optionName: String!
  optionValue: String!
}

input OrderOptionValuesScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  optionName: String
  optionName_not: String
  optionName_in: [String!]
  optionName_not_in: [String!]
  optionName_lt: String
  optionName_lte: String
  optionName_gt: String
  optionName_gte: String
  optionName_contains: String
  optionName_not_contains: String
  optionName_starts_with: String
  optionName_not_starts_with: String
  optionName_ends_with: String
  optionName_not_ends_with: String
  optionValue: String
  optionValue_not: String
  optionValue_in: [String!]
  optionValue_not_in: [String!]
  optionValue_lt: String
  optionValue_lte: String
  optionValue_gt: String
  optionValue_gte: String
  optionValue_contains: String
  optionValue_not_contains: String
  optionValue_starts_with: String
  optionValue_not_starts_with: String
  optionValue_ends_with: String
  optionValue_not_ends_with: String
  AND: [OrderOptionValuesScalarWhereInput!]
  OR: [OrderOptionValuesScalarWhereInput!]
  NOT: [OrderOptionValuesScalarWhereInput!]
}

type OrderOptionValuesSubscriptionPayload {
  mutation: MutationType!
  node: OrderOptionValues
  updatedFields: [String!]
  previousValues: OrderOptionValuesPreviousValues
}

input OrderOptionValuesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderOptionValuesWhereInput
  AND: [OrderOptionValuesSubscriptionWhereInput!]
  OR: [OrderOptionValuesSubscriptionWhereInput!]
  NOT: [OrderOptionValuesSubscriptionWhereInput!]
}

input OrderOptionValuesUpdateDataInput {
  optionName: String
  optionValue: String
}

input OrderOptionValuesUpdateInput {
  optionName: String
  optionValue: String
}

input OrderOptionValuesUpdateManyDataInput {
  optionName: String
  optionValue: String
}

input OrderOptionValuesUpdateManyInput {
  create: [OrderOptionValuesCreateInput!]
  update: [OrderOptionValuesUpdateWithWhereUniqueNestedInput!]
  upsert: [OrderOptionValuesUpsertWithWhereUniqueNestedInput!]
  delete: [OrderOptionValuesWhereUniqueInput!]
  connect: [OrderOptionValuesWhereUniqueInput!]
  set: [OrderOptionValuesWhereUniqueInput!]
  disconnect: [OrderOptionValuesWhereUniqueInput!]
  deleteMany: [OrderOptionValuesScalarWhereInput!]
  updateMany: [OrderOptionValuesUpdateManyWithWhereNestedInput!]
}

input OrderOptionValuesUpdateManyMutationInput {
  optionName: String
  optionValue: String
}

input OrderOptionValuesUpdateManyWithWhereNestedInput {
  where: OrderOptionValuesScalarWhereInput!
  data: OrderOptionValuesUpdateManyDataInput!
}

input OrderOptionValuesUpdateWithWhereUniqueNestedInput {
  where: OrderOptionValuesWhereUniqueInput!
  data: OrderOptionValuesUpdateDataInput!
}

input OrderOptionValuesUpsertWithWhereUniqueNestedInput {
  where: OrderOptionValuesWhereUniqueInput!
  update: OrderOptionValuesUpdateDataInput!
  create: OrderOptionValuesCreateInput!
}

input OrderOptionValuesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  optionName: String
  optionName_not: String
  optionName_in: [String!]
  optionName_not_in: [String!]
  optionName_lt: String
  optionName_lte: String
  optionName_gt: String
  optionName_gte: String
  optionName_contains: String
  optionName_not_contains: String
  optionName_starts_with: String
  optionName_not_starts_with: String
  optionName_ends_with: String
  optionName_not_ends_with: String
  optionValue: String
  optionValue_not: String
  optionValue_in: [String!]
  optionValue_not_in: [String!]
  optionValue_lt: String
  optionValue_lte: String
  optionValue_gt: String
  optionValue_gte: String
  optionValue_contains: String
  optionValue_not_contains: String
  optionValue_starts_with: String
  optionValue_not_starts_with: String
  optionValue_ends_with: String
  optionValue_not_ends_with: String
  AND: [OrderOptionValuesWhereInput!]
  OR: [OrderOptionValuesWhereInput!]
  NOT: [OrderOptionValuesWhereInput!]
}

input OrderOptionValuesWhereUniqueInput {
  id: ID
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  subTotalBeforeTax_ASC
  subTotalBeforeTax_DESC
  subTotal_ASC
  subTotal_DESC
  state_ASC
  state_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrderPreviousValues {
  id: ID!
  createdAt: DateTime!
  subTotalBeforeTax: Int!
  subTotal: Int!
  state: OrderState!
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  subTotalBeforeTax: Int
  subTotalBeforeTax_not: Int
  subTotalBeforeTax_in: [Int!]
  subTotalBeforeTax_not_in: [Int!]
  subTotalBeforeTax_lt: Int
  subTotalBeforeTax_lte: Int
  subTotalBeforeTax_gt: Int
  subTotalBeforeTax_gte: Int
  subTotal: Int
  subTotal_not: Int
  subTotal_in: [Int!]
  subTotal_not_in: [Int!]
  subTotal_lt: Int
  subTotal_lte: Int
  subTotal_gt: Int
  subTotal_gte: Int
  state: OrderState
  state_not: OrderState
  state_in: [OrderState!]
  state_not_in: [OrderState!]
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

enum OrderState {
  COMPLETE
  CANCELLED
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  items: OrderLineItemUpdateManyInput
  customer: UserUpdateOneRequiredWithoutOrdersInput
  subTotalBeforeTax: Int
  subTotal: Int
  payment: PaymentUpdateOneRequiredWithoutOrderInput
  state: OrderState
}

input OrderUpdateManyDataInput {
  subTotalBeforeTax: Int
  subTotal: Int
  state: OrderState
}

input OrderUpdateManyMutationInput {
  subTotalBeforeTax: Int
  subTotal: Int
  state: OrderState
}

input OrderUpdateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneRequiredWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  update: OrderUpdateWithoutPaymentDataInput
  upsert: OrderUpsertWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutCustomerDataInput {
  items: OrderLineItemUpdateManyInput
  subTotalBeforeTax: Int
  subTotal: Int
  payment: PaymentUpdateOneRequiredWithoutOrderInput
  state: OrderState
}

input OrderUpdateWithoutPaymentDataInput {
  items: OrderLineItemUpdateManyInput
  customer: UserUpdateOneRequiredWithoutOrdersInput
  subTotalBeforeTax: Int
  subTotal: Int
  state: OrderState
}

input OrderUpdateWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutCustomerDataInput!
}

input OrderUpsertWithoutPaymentInput {
  update: OrderUpdateWithoutPaymentDataInput!
  create: OrderCreateWithoutPaymentInput!
}

input OrderUpsertWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutCustomerDataInput!
  create: OrderCreateWithoutCustomerInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  items_every: OrderLineItemWhereInput
  items_some: OrderLineItemWhereInput
  items_none: OrderLineItemWhereInput
  customer: UserWhereInput
  subTotalBeforeTax: Int
  subTotalBeforeTax_not: Int
  subTotalBeforeTax_in: [Int!]
  subTotalBeforeTax_not_in: [Int!]
  subTotalBeforeTax_lt: Int
  subTotalBeforeTax_lte: Int
  subTotalBeforeTax_gt: Int
  subTotalBeforeTax_gte: Int
  subTotal: Int
  subTotal_not: Int
  subTotal_in: [Int!]
  subTotal_not_in: [Int!]
  subTotal_lt: Int
  subTotal_lte: Int
  subTotal_gt: Int
  subTotal_gte: Int
  payment: PaymentWhereInput
  state: OrderState
  state_not: OrderState
  state_in: [OrderState!]
  state_not_in: [OrderState!]
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  method: PaymentMethod!
  amount: Int!
  state: PaymentState!
  order: Order!
  currencyCode: CurrencyCode!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  method: PaymentMethod!
  amount: Int!
  state: PaymentState!
  order: OrderCreateOneWithoutPaymentInput!
  currencyCode: CurrencyCode!
}

input PaymentCreateOneWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutOrderInput {
  method: PaymentMethod!
  amount: Int!
  state: PaymentState!
  currencyCode: CurrencyCode!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentMethod {
  PAYPAL
  STRIPE
  CREDIT_CARD
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  method_ASC
  method_DESC
  amount_ASC
  amount_DESC
  state_ASC
  state_DESC
  currencyCode_ASC
  currencyCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  method: PaymentMethod!
  amount: Int!
  state: PaymentState!
  currencyCode: CurrencyCode!
}

enum PaymentState {
  AUTHORIZED
  SETTLED
  DECLINED
  REFUNDED
  CANCELLED
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  method: PaymentMethod
  amount: Int
  state: PaymentState
  order: OrderUpdateOneRequiredWithoutPaymentInput
  currencyCode: CurrencyCode
}

input PaymentUpdateManyMutationInput {
  method: PaymentMethod
  amount: Int
  state: PaymentState
  currencyCode: CurrencyCode
}

input PaymentUpdateOneRequiredWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  update: PaymentUpdateWithoutOrderDataInput
  upsert: PaymentUpsertWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutOrderDataInput {
  method: PaymentMethod
  amount: Int
  state: PaymentState
  currencyCode: CurrencyCode
}

input PaymentUpsertWithoutOrderInput {
  update: PaymentUpdateWithoutOrderDataInput!
  create: PaymentCreateWithoutOrderInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  method: PaymentMethod
  method_not: PaymentMethod
  method_in: [PaymentMethod!]
  method_not_in: [PaymentMethod!]
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  state: PaymentState
  state_not: PaymentState
  state_in: [PaymentState!]
  state_not_in: [PaymentState!]
  order: OrderWhereInput
  currencyCode: CurrencyCode
  currencyCode_not: CurrencyCode
  currencyCode_in: [CurrencyCode!]
  currencyCode_not_in: [CurrencyCode!]
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  slug: String!
  name: String!
  brand: Brand!
  description: String!
  type: ProductType
  thumbnail: Image!
  variants(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variant!]
  collections(where: CollectionWhereInput, orderBy: CollectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Collection!]
  attributes(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute!]
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  description: String!
  type: ProductTypeCreateOneInput
  thumbnail: ImageCreateOneInput!
  variants: VariantCreateManyInput
  collections: CollectionCreateManyWithoutProductsInput
  attributes: AttributeCreateManyWithoutProductsInput
}

input ProductCreateManyWithoutAttributesInput {
  create: [ProductCreateWithoutAttributesInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateManyWithoutCollectionsInput {
  create: [ProductCreateWithoutCollectionsInput!]
  connect: [ProductWhereUniqueInput!]
}

input ProductCreateWithoutAttributesInput {
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  description: String!
  type: ProductTypeCreateOneInput
  thumbnail: ImageCreateOneInput!
  variants: VariantCreateManyInput
  collections: CollectionCreateManyWithoutProductsInput
}

input ProductCreateWithoutBrandInput {
  slug: String!
  name: String!
  description: String!
  type: ProductTypeCreateOneInput
  thumbnail: ImageCreateOneInput!
  variants: VariantCreateManyInput
  collections: CollectionCreateManyWithoutProductsInput
  attributes: AttributeCreateManyWithoutProductsInput
}

input ProductCreateWithoutCollectionsInput {
  slug: String!
  name: String!
  brand: BrandCreateOneWithoutProductsInput!
  description: String!
  type: ProductTypeCreateOneInput
  thumbnail: ImageCreateOneInput!
  variants: VariantCreateManyInput
  attributes: AttributeCreateManyWithoutProductsInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  slug: String!
  name: String!
  description: String!
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

type ProductType {
  id: ID!
  name: String!
}

type ProductTypeConnection {
  pageInfo: PageInfo!
  edges: [ProductTypeEdge]!
  aggregate: AggregateProductType!
}

input ProductTypeCreateInput {
  name: String!
}

input ProductTypeCreateOneInput {
  create: ProductTypeCreateInput
  connect: ProductTypeWhereUniqueInput
}

type ProductTypeEdge {
  node: ProductType!
  cursor: String!
}

enum ProductTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductTypePreviousValues {
  id: ID!
  name: String!
}

type ProductTypeSubscriptionPayload {
  mutation: MutationType!
  node: ProductType
  updatedFields: [String!]
  previousValues: ProductTypePreviousValues
}

input ProductTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductTypeWhereInput
  AND: [ProductTypeSubscriptionWhereInput!]
  OR: [ProductTypeSubscriptionWhereInput!]
  NOT: [ProductTypeSubscriptionWhereInput!]
}

input ProductTypeUpdateDataInput {
  name: String
}

input ProductTypeUpdateInput {
  name: String
}

input ProductTypeUpdateManyMutationInput {
  name: String
}

input ProductTypeUpdateOneInput {
  create: ProductTypeCreateInput
  update: ProductTypeUpdateDataInput
  upsert: ProductTypeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductTypeWhereUniqueInput
}

input ProductTypeUpsertNestedInput {
  update: ProductTypeUpdateDataInput!
  create: ProductTypeCreateInput!
}

input ProductTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ProductTypeWhereInput!]
  OR: [ProductTypeWhereInput!]
  NOT: [ProductTypeWhereInput!]
}

input ProductTypeWhereUniqueInput {
  id: ID
}

input ProductUpdateInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  description: String
  type: ProductTypeUpdateOneInput
  thumbnail: ImageUpdateOneRequiredInput
  variants: VariantUpdateManyInput
  collections: CollectionUpdateManyWithoutProductsInput
  attributes: AttributeUpdateManyWithoutProductsInput
}

input ProductUpdateManyDataInput {
  slug: String
  name: String
  description: String
}

input ProductUpdateManyMutationInput {
  slug: String
  name: String
  description: String
}

input ProductUpdateManyWithoutAttributesInput {
  create: [ProductCreateWithoutAttributesInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutAttributesInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutAttributesInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutBrandInput {
  create: [ProductCreateWithoutBrandInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutBrandInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutBrandInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithoutCollectionsInput {
  create: [ProductCreateWithoutCollectionsInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCollectionsInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCollectionsInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateWithoutAttributesDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  description: String
  type: ProductTypeUpdateOneInput
  thumbnail: ImageUpdateOneRequiredInput
  variants: VariantUpdateManyInput
  collections: CollectionUpdateManyWithoutProductsInput
}

input ProductUpdateWithoutBrandDataInput {
  slug: String
  name: String
  description: String
  type: ProductTypeUpdateOneInput
  thumbnail: ImageUpdateOneRequiredInput
  variants: VariantUpdateManyInput
  collections: CollectionUpdateManyWithoutProductsInput
  attributes: AttributeUpdateManyWithoutProductsInput
}

input ProductUpdateWithoutCollectionsDataInput {
  slug: String
  name: String
  brand: BrandUpdateOneRequiredWithoutProductsInput
  description: String
  type: ProductTypeUpdateOneInput
  thumbnail: ImageUpdateOneRequiredInput
  variants: VariantUpdateManyInput
  attributes: AttributeUpdateManyWithoutProductsInput
}

input ProductUpdateWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutAttributesDataInput!
}

input ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutBrandDataInput!
}

input ProductUpdateWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateWithoutCollectionsDataInput!
}

input ProductUpsertWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutAttributesDataInput!
  create: ProductCreateWithoutAttributesInput!
}

input ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutBrandDataInput!
  create: ProductCreateWithoutBrandInput!
}

input ProductUpsertWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateWithoutCollectionsDataInput!
  create: ProductCreateWithoutCollectionsInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  brand: BrandWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: ProductTypeWhereInput
  thumbnail: ImageWhereInput
  variants_every: VariantWhereInput
  variants_some: VariantWhereInput
  variants_none: VariantWhereInput
  collections_every: CollectionWhereInput
  collections_some: CollectionWhereInput
  collections_none: CollectionWhereInput
  attributes_every: AttributeWhereInput
  attributes_some: AttributeWhereInput
  attributes_none: AttributeWhereInput
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
  slug: String
}

type Query {
  attribute(where: AttributeWhereUniqueInput!): Attribute
  attributes(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attribute]!
  attributesConnection(where: AttributeWhereInput, orderBy: AttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttributeConnection!
  brand(where: BrandWhereUniqueInput!): Brand
  brands(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Brand]!
  brandsConnection(where: BrandWhereInput, orderBy: BrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BrandConnection!
  collection(where: CollectionWhereUniqueInput!): Collection
  collections(where: CollectionWhereInput, orderBy: CollectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Collection]!
  collectionsConnection(where: CollectionWhereInput, orderBy: CollectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CollectionConnection!
  collectionRule(where: CollectionRuleWhereUniqueInput!): CollectionRule
  collectionRules(where: CollectionRuleWhereInput, orderBy: CollectionRuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CollectionRule]!
  collectionRulesConnection(where: CollectionRuleWhereInput, orderBy: CollectionRuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CollectionRuleConnection!
  collectionRuleSet(where: CollectionRuleSetWhereUniqueInput!): CollectionRuleSet
  collectionRuleSets(where: CollectionRuleSetWhereInput, orderBy: CollectionRuleSetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CollectionRuleSet]!
  collectionRuleSetsConnection(where: CollectionRuleSetWhereInput, orderBy: CollectionRuleSetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CollectionRuleSetConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  option(where: OptionWhereUniqueInput!): Option
  options(where: OptionWhereInput, orderBy: OptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Option]!
  optionsConnection(where: OptionWhereInput, orderBy: OptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OptionConnection!
  optionValue(where: OptionValueWhereUniqueInput!): OptionValue
  optionValues(where: OptionValueWhereInput, orderBy: OptionValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OptionValue]!
  optionValuesConnection(where: OptionValueWhereInput, orderBy: OptionValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OptionValueConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  orderLineItem(where: OrderLineItemWhereUniqueInput!): OrderLineItem
  orderLineItems(where: OrderLineItemWhereInput, orderBy: OrderLineItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderLineItem]!
  orderLineItemsConnection(where: OrderLineItemWhereInput, orderBy: OrderLineItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderLineItemConnection!
  orderOptionValues(where: OrderOptionValuesWhereUniqueInput!): OrderOptionValues
  orderOptionValueses(where: OrderOptionValuesWhereInput, orderBy: OrderOptionValuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderOptionValues]!
  orderOptionValuesesConnection(where: OrderOptionValuesWhereInput, orderBy: OrderOptionValuesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderOptionValuesConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productType(where: ProductTypeWhereUniqueInput!): ProductType
  productTypes(where: ProductTypeWhereInput, orderBy: ProductTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductType]!
  productTypesConnection(where: ProductTypeWhereInput, orderBy: ProductTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductTypeConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  variant(where: VariantWhereUniqueInput!): Variant
  variants(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variant]!
  variantsConnection(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VariantConnection!
  node(id: ID!): Node
}

type Subscription {
  attribute(where: AttributeSubscriptionWhereInput): AttributeSubscriptionPayload
  brand(where: BrandSubscriptionWhereInput): BrandSubscriptionPayload
  collection(where: CollectionSubscriptionWhereInput): CollectionSubscriptionPayload
  collectionRule(where: CollectionRuleSubscriptionWhereInput): CollectionRuleSubscriptionPayload
  collectionRuleSet(where: CollectionRuleSetSubscriptionWhereInput): CollectionRuleSetSubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  option(where: OptionSubscriptionWhereInput): OptionSubscriptionPayload
  optionValue(where: OptionValueSubscriptionWhereInput): OptionValueSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  orderLineItem(where: OrderLineItemSubscriptionWhereInput): OrderLineItemSubscriptionPayload
  orderOptionValues(where: OrderOptionValuesSubscriptionWhereInput): OrderOptionValuesSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productType(where: ProductTypeSubscriptionWhereInput): ProductTypeSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  variant(where: VariantSubscriptionWhereInput): VariantSubscriptionPayload
}

type User {
  id: ID!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  cart(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variant!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  orders: OrderCreateManyWithoutCustomerInput
  cart: VariantCreateManyInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutOrdersInput {
  cart: VariantCreateManyInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  orders: OrderUpdateManyWithoutCustomerInput
  cart: VariantUpdateManyInput
}

input UserUpdateInput {
  orders: OrderUpdateManyWithoutCustomerInput
  cart: VariantUpdateManyInput
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutOrdersDataInput {
  cart: VariantUpdateManyInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput!
  create: UserCreateWithoutOrdersInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  cart_every: VariantWhereInput
  cart_some: VariantWhereInput
  cart_none: VariantWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}

type Variant {
  id: ID!
  optionValues(where: OptionValueWhereInput, orderBy: OptionValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OptionValue!]
  price: Int!
  availableForSale: Boolean
  sku: String
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
}

type VariantConnection {
  pageInfo: PageInfo!
  edges: [VariantEdge]!
  aggregate: AggregateVariant!
}

input VariantCreateInput {
  optionValues: OptionValueCreateManyInput
  price: Int!
  availableForSale: Boolean
  sku: String
  images: ImageCreateManyInput
}

input VariantCreateManyInput {
  create: [VariantCreateInput!]
  connect: [VariantWhereUniqueInput!]
}

type VariantEdge {
  node: Variant!
  cursor: String!
}

enum VariantOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  availableForSale_ASC
  availableForSale_DESC
  sku_ASC
  sku_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VariantPreviousValues {
  id: ID!
  price: Int!
  availableForSale: Boolean
  sku: String
}

input VariantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  availableForSale: Boolean
  availableForSale_not: Boolean
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  AND: [VariantScalarWhereInput!]
  OR: [VariantScalarWhereInput!]
  NOT: [VariantScalarWhereInput!]
}

type VariantSubscriptionPayload {
  mutation: MutationType!
  node: Variant
  updatedFields: [String!]
  previousValues: VariantPreviousValues
}

input VariantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VariantWhereInput
  AND: [VariantSubscriptionWhereInput!]
  OR: [VariantSubscriptionWhereInput!]
  NOT: [VariantSubscriptionWhereInput!]
}

input VariantUpdateDataInput {
  optionValues: OptionValueUpdateManyInput
  price: Int
  availableForSale: Boolean
  sku: String
  images: ImageUpdateManyInput
}

input VariantUpdateInput {
  optionValues: OptionValueUpdateManyInput
  price: Int
  availableForSale: Boolean
  sku: String
  images: ImageUpdateManyInput
}

input VariantUpdateManyDataInput {
  price: Int
  availableForSale: Boolean
  sku: String
}

input VariantUpdateManyInput {
  create: [VariantCreateInput!]
  update: [VariantUpdateWithWhereUniqueNestedInput!]
  upsert: [VariantUpsertWithWhereUniqueNestedInput!]
  delete: [VariantWhereUniqueInput!]
  connect: [VariantWhereUniqueInput!]
  set: [VariantWhereUniqueInput!]
  disconnect: [VariantWhereUniqueInput!]
  deleteMany: [VariantScalarWhereInput!]
  updateMany: [VariantUpdateManyWithWhereNestedInput!]
}

input VariantUpdateManyMutationInput {
  price: Int
  availableForSale: Boolean
  sku: String
}

input VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput!
  data: VariantUpdateManyDataInput!
}

input VariantUpdateWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput!
  data: VariantUpdateDataInput!
}

input VariantUpsertWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput!
  update: VariantUpdateDataInput!
  create: VariantCreateInput!
}

input VariantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  optionValues_every: OptionValueWhereInput
  optionValues_some: OptionValueWhereInput
  optionValues_none: OptionValueWhereInput
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  availableForSale: Boolean
  availableForSale_not: Boolean
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  images_every: ImageWhereInput
  images_some: ImageWhereInput
  images_none: ImageWhereInput
  AND: [VariantWhereInput!]
  OR: [VariantWhereInput!]
  NOT: [VariantWhereInput!]
}

input VariantWhereUniqueInput {
  id: ID
}
`