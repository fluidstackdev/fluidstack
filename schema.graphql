### This file was autogenerated by graphqliteral
### Do not make changes to this file directly

type Attribute {
  id: ID!
  key: String!
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]!
  value: String!
}

input AttributeWhereInput {
  AND: [AttributeWhereInput!]!
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]!
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]!
  key_not_starts_with: String
  key_starts_with: String
  NOT: [AttributeWhereInput!]!
  OR: [AttributeWhereInput!]!
  products_every: ProductWhereInput
  products_none: ProductWhereInput
  products_some: ProductWhereInput
  value: String
  value_contains: String
  value_ends_with: String
  value_gt: String
  value_gte: String
  value_in: [String!]!
  value_lt: String
  value_lte: String
  value_not: String
  value_not_contains: String
  value_not_ends_with: String
  value_not_in: [String!]!
  value_not_starts_with: String
  value_starts_with: String
}

type Brand {
  id: ID!
  name: String!
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]!
}

type BrandConnection {
  edges: [BrandEdge!]!
  pageInfo: PageInfo!
}

type BrandEdge {
  cursor: String!
  node: Brand!
}

enum BrandOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input BrandWhereInput {
  AND: [BrandWhereInput!]!
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]!
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]!
  name_not_starts_with: String
  name_starts_with: String
  NOT: [BrandWhereInput!]!
  OR: [BrandWhereInput!]!
  products_every: ProductWhereInput
  products_none: ProductWhereInput
  products_some: ProductWhereInput
}

type Collection {
  attributes: [Attribute!]!
  brands: [Brand!]!
  id: ID!
  name: String!
  options: [Option!]!
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]!
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]!
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]!
  name_not_starts_with: String
  name_starts_with: String
  NOT: [CollectionWhereInput!]!
  OR: [CollectionWhereInput!]!
  products_every: ProductWhereInput
  products_none: ProductWhereInput
  products_some: ProductWhereInput
}

input CreateProductInput {
  attributesIds: [UniqueInput!]!
  brand: UniqueInput!
  name: String!
  variants: [CreateVariantInput!]!
}

input CreateVariantInput {
  availableForSale: Boolean!
  optionsValueIds: [UniqueInput!]!
  price: Int!
}

type Mutation {
  addProductsToCollection(collectionId: ID!, productIds: [ID!]!): Collection!
  createProduct(data: CreateProductInput!): Product!
  removeProductsFromCollection(collectionId: ID!, productIds: [ID!]!): Collection!
  updateProduct(data: UpdateProductInput!): Product!
}

type Option {
  id: ID!
  name: String!
  values(after: String, before: String, first: Int, last: Int, orderBy: OptionValueOrderByInput, skip: Int, where: OptionValueWhereInput): [OptionValue!]!
}

type OptionConnection {
  edges: [OptionEdge!]!
  pageInfo: PageInfo!
}

type OptionEdge {
  cursor: String!
  node: Option!
}

enum OptionOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OptionValue {
  id: ID!
  name: String!
  option: Option!
}

enum OptionValueOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input OptionValueWhereInput {
  AND: [OptionValueWhereInput!]!
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]!
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]!
  name_not_starts_with: String
  name_starts_with: String
  NOT: [OptionValueWhereInput!]!
  option: OptionWhereInput
  OR: [OptionValueWhereInput!]!
}

input OptionWhereInput {
  AND: [OptionWhereInput!]!
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]!
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]!
  name_not_starts_with: String
  name_starts_with: String
  NOT: [OptionWhereInput!]!
  OR: [OptionWhereInput!]!
  values_every: OptionValueWhereInput
  values_none: OptionValueWhereInput
  values_some: OptionValueWhereInput
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Product {
  brand: Brand!
  id: ID!
  name: String!
  options: [Option!]!
  variants(after: String, before: String, first: Int, last: Int, orderBy: VariantOrderByInput, skip: Int, where: VariantWhereInput): [Variant!]!
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
}

type ProductEdge {
  cursor: String!
  node: Product!
}

enum ProductOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProductWhereInput {
  AND: [ProductWhereInput!]!
  attributes_every: AttributeWhereInput
  attributes_none: AttributeWhereInput
  attributes_some: AttributeWhereInput
  brand: BrandWhereInput
  collections_every: CollectionWhereInput
  collections_none: CollectionWhereInput
  collections_some: CollectionWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]!
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]!
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductWhereInput!]!
  OR: [ProductWhereInput!]!
  variants_every: VariantWhereInput
  variants_none: VariantWhereInput
  variants_some: VariantWhereInput
}

type Query {
  brands(after: String, before: String, first: Int, last: Int, orderBy: BrandOrderByInput, skip: Int, where: BrandWhereInput): BrandConnection!
  collection(collectionId: ID!): Collection!
  options(after: String, before: String, first: Int, last: Int, orderBy: OptionOrderByInput, skip: Int, where: OptionWhereInput): OptionConnection!
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): ProductConnection!
}

input UniqueInput {
  id: ID!
}

input UpdateProductInput {
  attributesIds: [UniqueInput!]!
  brand: UniqueInput!
  id: ID!
  name: String!
  variants: [UpdateVariantInput!]!
}

input UpdateVariantInput {
  availableForSale: Boolean!
  id: ID!
  optionsValueIds: [UniqueInput!]!
  price: Int!
}

type Variant {
  id: ID!
  optionValues(after: String, before: String, first: Int, last: Int, orderBy: OptionValueOrderByInput, skip: Int, where: OptionValueWhereInput): [OptionValue!]!
  price: Int
}

enum VariantOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input VariantWhereInput {
  AND: [VariantWhereInput!]!
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]!
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]!
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [VariantWhereInput!]!
  optionValues_every: OptionValueWhereInput
  optionValues_none: OptionValueWhereInput
  optionValues_some: OptionValueWhereInput
  OR: [VariantWhereInput!]!
  price: Int
  price_gt: Int
  price_gte: Int
  price_in: [Int!]!
  price_lt: Int
  price_lte: Int
  price_not: Int
  price_not_in: [Int!]!
}
