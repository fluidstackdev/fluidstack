// Code generated by Prisma (prisma@1.23.0-beta.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attribute: (where?: AttributeWhereInput) => Promise<boolean>;
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  collection: (where?: CollectionWhereInput) => Promise<boolean>;
  option: (where?: OptionWhereInput) => Promise<boolean>;
  optionValue: (where?: OptionValueWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  variant: (where?: VariantWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  attributes: (
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Attribute>;
  attributesConnection: (
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AttributeConnectionPromise;
  brand: (where: BrandWhereUniqueInput) => BrandPromise;
  brands: (
    args?: {
      where?: BrandWhereInput;
      orderBy?: BrandOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Brand>;
  brandsConnection: (
    args?: {
      where?: BrandWhereInput;
      orderBy?: BrandOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BrandConnectionPromise;
  collection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  collections: (
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Collection>;
  collectionsConnection: (
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CollectionConnectionPromise;
  option: (where: OptionWhereUniqueInput) => OptionPromise;
  options: (
    args?: {
      where?: OptionWhereInput;
      orderBy?: OptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Option>;
  optionsConnection: (
    args?: {
      where?: OptionWhereInput;
      orderBy?: OptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OptionConnectionPromise;
  optionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  optionValues: (
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<OptionValue>;
  optionValuesConnection: (
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OptionValueConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  variant: (where: VariantWhereUniqueInput) => VariantPromise;
  variants: (
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Variant>;
  variantsConnection: (
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VariantConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttribute: (data: AttributeCreateInput) => AttributePromise;
  updateAttribute: (
    args: { data: AttributeUpdateInput; where: AttributeWhereUniqueInput }
  ) => AttributePromise;
  updateManyAttributes: (
    args: {
      data: AttributeUpdateManyMutationInput;
      where?: AttributeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAttribute: (
    args: {
      where: AttributeWhereUniqueInput;
      create: AttributeCreateInput;
      update: AttributeUpdateInput;
    }
  ) => AttributePromise;
  deleteAttribute: (where: AttributeWhereUniqueInput) => AttributePromise;
  deleteManyAttributes: (where?: AttributeWhereInput) => BatchPayloadPromise;
  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (
    args: { data: BrandUpdateInput; where: BrandWhereUniqueInput }
  ) => BrandPromise;
  updateManyBrands: (
    args: { data: BrandUpdateManyMutationInput; where?: BrandWhereInput }
  ) => BatchPayloadPromise;
  upsertBrand: (
    args: {
      where: BrandWhereUniqueInput;
      create: BrandCreateInput;
      update: BrandUpdateInput;
    }
  ) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCollection: (data: CollectionCreateInput) => CollectionPromise;
  updateCollection: (
    args: { data: CollectionUpdateInput; where: CollectionWhereUniqueInput }
  ) => CollectionPromise;
  updateManyCollections: (
    args: {
      data: CollectionUpdateManyMutationInput;
      where?: CollectionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCollection: (
    args: {
      where: CollectionWhereUniqueInput;
      create: CollectionCreateInput;
      update: CollectionUpdateInput;
    }
  ) => CollectionPromise;
  deleteCollection: (where: CollectionWhereUniqueInput) => CollectionPromise;
  deleteManyCollections: (where?: CollectionWhereInput) => BatchPayloadPromise;
  createOption: (data: OptionCreateInput) => OptionPromise;
  updateOption: (
    args: { data: OptionUpdateInput; where: OptionWhereUniqueInput }
  ) => OptionPromise;
  updateManyOptions: (
    args: { data: OptionUpdateManyMutationInput; where?: OptionWhereInput }
  ) => BatchPayloadPromise;
  upsertOption: (
    args: {
      where: OptionWhereUniqueInput;
      create: OptionCreateInput;
      update: OptionUpdateInput;
    }
  ) => OptionPromise;
  deleteOption: (where: OptionWhereUniqueInput) => OptionPromise;
  deleteManyOptions: (where?: OptionWhereInput) => BatchPayloadPromise;
  createOptionValue: (data: OptionValueCreateInput) => OptionValuePromise;
  updateOptionValue: (
    args: { data: OptionValueUpdateInput; where: OptionValueWhereUniqueInput }
  ) => OptionValuePromise;
  updateManyOptionValues: (
    args: {
      data: OptionValueUpdateManyMutationInput;
      where?: OptionValueWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertOptionValue: (
    args: {
      where: OptionValueWhereUniqueInput;
      create: OptionValueCreateInput;
      update: OptionValueUpdateInput;
    }
  ) => OptionValuePromise;
  deleteOptionValue: (where: OptionValueWhereUniqueInput) => OptionValuePromise;
  deleteManyOptionValues: (
    where?: OptionValueWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createVariant: (data: VariantCreateInput) => VariantPromise;
  updateVariant: (
    args: { data: VariantUpdateInput; where: VariantWhereUniqueInput }
  ) => VariantPromise;
  updateManyVariants: (
    args: { data: VariantUpdateManyMutationInput; where?: VariantWhereInput }
  ) => BatchPayloadPromise;
  upsertVariant: (
    args: {
      where: VariantWhereUniqueInput;
      create: VariantCreateInput;
      update: VariantUpdateInput;
    }
  ) => VariantPromise;
  deleteVariant: (where: VariantWhereUniqueInput) => VariantPromise;
  deleteManyVariants: (where?: VariantWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attribute: (
    where?: AttributeSubscriptionWhereInput
  ) => AttributeSubscriptionPayloadSubscription;
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  collection: (
    where?: CollectionSubscriptionWhereInput
  ) => CollectionSubscriptionPayloadSubscription;
  option: (
    where?: OptionSubscriptionWhereInput
  ) => OptionSubscriptionPayloadSubscription;
  optionValue: (
    where?: OptionValueSubscriptionWhereInput
  ) => OptionValueSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  variant: (
    where?: VariantSubscriptionWhereInput
  ) => VariantSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptionValueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AttributeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface OptionValueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  OR?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  NOT?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
}

export type AttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput;
  data: VariantUpdateManyDataInput;
}

export interface CollectionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: CollectionWhereInput[] | CollectionWhereInput;
  OR?: CollectionWhereInput[] | CollectionWhereInput;
  NOT?: CollectionWhereInput[] | CollectionWhereInput;
}

export interface AttributeUpdateInput {
  key?: String;
  value?: String;
  products?: ProductUpdateManyWithoutAttributesInput;
}

export interface ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutBrandDataInput;
  create: ProductCreateWithoutBrandInput;
}

export interface ProductUpdateManyWithoutAttributesInput {
  create?:
    | ProductCreateWithoutAttributesInput[]
    | ProductCreateWithoutAttributesInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutAttributesInput[]
    | ProductUpdateWithWhereUniqueWithoutAttributesInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutAttributesInput[]
    | ProductUpsertWithWhereUniqueWithoutAttributesInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface VariantUpdateManyDataInput {
  price?: Int;
}

export interface ProductUpdateWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutAttributesDataInput;
}

export interface OptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  values_every?: OptionValueWhereInput;
  values_some?: OptionValueWhereInput;
  values_none?: OptionValueWhereInput;
  AND?: OptionWhereInput[] | OptionWhereInput;
  OR?: OptionWhereInput[] | OptionWhereInput;
  NOT?: OptionWhereInput[] | OptionWhereInput;
}

export interface ProductUpdateWithoutAttributesDataInput {
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
}

export interface OptionValueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  option?: OptionWhereInput;
  AND?: OptionValueWhereInput[] | OptionValueWhereInput;
  OR?: OptionValueWhereInput[] | OptionValueWhereInput;
  NOT?: OptionValueWhereInput[] | OptionValueWhereInput;
}

export interface BrandUpdateOneRequiredWithoutProductsInput {
  create?: BrandCreateWithoutProductsInput;
  update?: BrandUpdateWithoutProductsDataInput;
  upsert?: BrandUpsertWithoutProductsInput;
  connect?: BrandWhereUniqueInput;
}

export interface OptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionWhereInput;
  AND?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  OR?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
  NOT?: OptionSubscriptionWhereInput[] | OptionSubscriptionWhereInput;
}

export interface BrandUpdateWithoutProductsDataInput {
  name?: String;
}

export interface CollectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollectionWhereInput;
  AND?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
  OR?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
  NOT?: CollectionSubscriptionWhereInput[] | CollectionSubscriptionWhereInput;
}

export interface BrandUpsertWithoutProductsInput {
  update: BrandUpdateWithoutProductsDataInput;
  create: BrandCreateWithoutProductsInput;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BrandWhereInput;
  AND?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
  OR?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
  NOT?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
}

export interface VariantUpdateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  update?:
    | VariantUpdateWithWhereUniqueNestedInput[]
    | VariantUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VariantUpsertWithWhereUniqueNestedInput[]
    | VariantUpsertWithWhereUniqueNestedInput;
  delete?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  disconnect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
  deleteMany?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  updateMany?:
    | VariantUpdateManyWithWhereNestedInput[]
    | VariantUpdateManyWithWhereNestedInput;
}

export interface VariantUpdateManyMutationInput {
  price?: Int;
}

export interface VariantUpdateWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  data: VariantUpdateDataInput;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
}

export interface VariantUpdateDataInput {
  optionValues?: OptionValueUpdateManyInput;
  price?: Int;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  brand?: BrandWhereInput;
  variants_every?: VariantWhereInput;
  variants_some?: VariantWhereInput;
  variants_none?: VariantWhereInput;
  collections_every?: CollectionWhereInput;
  collections_some?: CollectionWhereInput;
  collections_none?: CollectionWhereInput;
  attributes_every?: AttributeWhereInput;
  attributes_some?: AttributeWhereInput;
  attributes_none?: AttributeWhereInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface OptionValueUpdateManyInput {
  create?: OptionValueCreateInput[] | OptionValueCreateInput;
  update?:
    | OptionValueUpdateWithWhereUniqueNestedInput[]
    | OptionValueUpdateWithWhereUniqueNestedInput;
  upsert?:
    | OptionValueUpsertWithWhereUniqueNestedInput[]
    | OptionValueUpsertWithWhereUniqueNestedInput;
  delete?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  disconnect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  deleteMany?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  updateMany?:
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput;
}

export interface ProductCreateInput {
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface OptionValueUpdateWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateDataInput;
}

export type CollectionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OptionValueUpdateDataInput {
  name?: String;
  option?: OptionUpdateOneRequiredWithoutValuesInput;
}

export interface OptionUpdateManyMutationInput {
  name?: String;
}

export interface OptionUpdateOneRequiredWithoutValuesInput {
  create?: OptionCreateWithoutValuesInput;
  update?: OptionUpdateWithoutValuesDataInput;
  upsert?: OptionUpsertWithoutValuesInput;
  connect?: OptionWhereUniqueInput;
}

export type OptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OptionUpdateWithoutValuesDataInput {
  name?: String;
}

export interface OptionValueUpdateWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput;
  data: OptionValueUpdateWithoutOptionDataInput;
}

export interface OptionUpsertWithoutValuesInput {
  update: OptionUpdateWithoutValuesDataInput;
  create: OptionCreateWithoutValuesInput;
}

export interface OptionUpdateInput {
  name?: String;
  values?: OptionValueUpdateManyWithoutOptionInput;
}

export interface OptionValueUpsertWithWhereUniqueNestedInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateDataInput;
  create: OptionValueCreateInput;
}

export interface OptionValueCreateWithoutOptionInput {
  name: String;
}

export interface ProductCreateWithoutCollectionsInput {
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  variants?: VariantCreateManyInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface OptionCreateInput {
  name: String;
  values?: OptionValueCreateManyWithoutOptionInput;
}

export interface OptionValueUpdateManyWithWhereNestedInput {
  where: OptionValueScalarWhereInput;
  data: OptionValueUpdateManyDataInput;
}

export interface CollectionUpdateManyMutationInput {
  name?: String;
}

export interface OptionValueUpdateManyDataInput {
  name?: String;
}

export interface ProductUpdateWithoutCollectionsDataInput {
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  variants?: VariantUpdateManyInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface VariantUpsertWithWhereUniqueNestedInput {
  where: VariantWhereUniqueInput;
  update: VariantUpdateDataInput;
  create: VariantCreateInput;
}

export interface ProductUpdateWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCollectionsDataInput;
}

export interface VariantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  AND?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  OR?: VariantScalarWhereInput[] | VariantScalarWhereInput;
  NOT?: VariantScalarWhereInput[] | VariantScalarWhereInput;
}

export interface CollectionUpdateInput {
  name?: String;
  products?: ProductUpdateManyWithoutCollectionsInput;
}

export interface AttributeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: AttributeWhereInput[] | AttributeWhereInput;
  OR?: AttributeWhereInput[] | AttributeWhereInput;
  NOT?: AttributeWhereInput[] | AttributeWhereInput;
}

export interface AttributeCreateInput {
  key: String;
  value: String;
  products?: ProductCreateManyWithoutAttributesInput;
}

export interface ProductCreateManyWithoutCollectionsInput {
  create?:
    | ProductCreateWithoutCollectionsInput[]
    | ProductCreateWithoutCollectionsInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateWithoutAttributesInput {
  name: String;
  brand: BrandCreateOneWithoutProductsInput;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
}

export interface CollectionUpdateManyWithoutProductsInput {
  create?:
    | CollectionCreateWithoutProductsInput[]
    | CollectionCreateWithoutProductsInput;
  delete?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  connect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  disconnect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
  update?:
    | CollectionUpdateWithWhereUniqueWithoutProductsInput[]
    | CollectionUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | CollectionUpsertWithWhereUniqueWithoutProductsInput[]
    | CollectionUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  updateMany?:
    | CollectionUpdateManyWithWhereNestedInput[]
    | CollectionUpdateManyWithWhereNestedInput;
}

export interface BrandCreateWithoutProductsInput {
  name: String;
}

export interface CollectionUpdateWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput;
  data: CollectionUpdateWithoutProductsDataInput;
}

export interface VariantCreateInput {
  optionValues?: OptionValueCreateManyInput;
  price?: Int;
}

export interface CollectionUpdateWithoutProductsDataInput {
  name?: String;
}

export interface OptionValueCreateInput {
  name: String;
  option: OptionCreateOneWithoutValuesInput;
}

export interface CollectionUpsertWithWhereUniqueWithoutProductsInput {
  where: CollectionWhereUniqueInput;
  update: CollectionUpdateWithoutProductsDataInput;
  create: CollectionCreateWithoutProductsInput;
}

export interface OptionCreateWithoutValuesInput {
  name: String;
}

export interface CollectionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  OR?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
  NOT?: CollectionScalarWhereInput[] | CollectionScalarWhereInput;
}

export interface CollectionCreateWithoutProductsInput {
  name: String;
}

export interface CollectionUpdateManyWithWhereNestedInput {
  where: CollectionScalarWhereInput;
  data: CollectionUpdateManyDataInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface CollectionUpdateManyDataInput {
  name?: String;
}

export interface VariantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  optionValues_every?: OptionValueWhereInput;
  optionValues_some?: OptionValueWhereInput;
  optionValues_none?: OptionValueWhereInput;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  AND?: VariantWhereInput[] | VariantWhereInput;
  OR?: VariantWhereInput[] | VariantWhereInput;
  NOT?: VariantWhereInput[] | VariantWhereInput;
}

export interface ProductUpsertWithWhereUniqueWithoutAttributesInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutAttributesDataInput;
  create: ProductCreateWithoutAttributesInput;
}

export interface AttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttributeWhereInput;
  AND?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  OR?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
  NOT?: AttributeSubscriptionWhereInput[] | AttributeSubscriptionWhereInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export type BrandWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface OptionValueUpdateManyMutationInput {
  name?: String;
}

export interface ProductUpdateManyDataInput {
  name?: String;
}

export interface OptionValueUpsertWithWhereUniqueWithoutOptionInput {
  where: OptionValueWhereUniqueInput;
  update: OptionValueUpdateWithoutOptionDataInput;
  create: OptionValueCreateWithoutOptionInput;
}

export interface AttributeUpdateManyMutationInput {
  key?: String;
  value?: String;
}

export interface OptionValueUpdateManyWithoutOptionInput {
  create?:
    | OptionValueCreateWithoutOptionInput[]
    | OptionValueCreateWithoutOptionInput;
  delete?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  disconnect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
  update?:
    | OptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    | OptionValueUpdateWithWhereUniqueWithoutOptionInput;
  upsert?:
    | OptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    | OptionValueUpsertWithWhereUniqueWithoutOptionInput;
  deleteMany?: OptionValueScalarWhereInput[] | OptionValueScalarWhereInput;
  updateMany?:
    | OptionValueUpdateManyWithWhereNestedInput[]
    | OptionValueUpdateManyWithWhereNestedInput;
}

export interface CollectionCreateInput {
  name: String;
  products?: ProductCreateManyWithoutCollectionsInput;
}

export interface OptionValueCreateManyWithoutOptionInput {
  create?:
    | OptionValueCreateWithoutOptionInput[]
    | OptionValueCreateWithoutOptionInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
}

export interface BrandUpdateManyMutationInput {
  name?: String;
}

export interface ProductUpsertWithWhereUniqueWithoutCollectionsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCollectionsDataInput;
  create: ProductCreateWithoutCollectionsInput;
}

export interface BrandCreateInput {
  name: String;
  products?: ProductCreateManyWithoutBrandInput;
}

export interface ProductUpdateManyWithoutCollectionsInput {
  create?:
    | ProductCreateWithoutCollectionsInput[]
    | ProductCreateWithoutCollectionsInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutCollectionsInput[]
    | ProductUpdateWithWhereUniqueWithoutCollectionsInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutCollectionsInput[]
    | ProductUpsertWithWhereUniqueWithoutCollectionsInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductCreateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateManyWithoutAttributesInput {
  create?:
    | ProductCreateWithoutAttributesInput[]
    | ProductCreateWithoutAttributesInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateWithoutBrandInput {
  name: String;
  variants?: VariantCreateManyInput;
  collections?: CollectionCreateManyWithoutProductsInput;
  attributes?: AttributeCreateManyWithoutProductsInput;
}

export interface VariantCreateManyInput {
  create?: VariantCreateInput[] | VariantCreateInput;
  connect?: VariantWhereUniqueInput[] | VariantWhereUniqueInput;
}

export interface AttributeCreateManyWithoutProductsInput {
  create?:
    | AttributeCreateWithoutProductsInput[]
    | AttributeCreateWithoutProductsInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
}

export interface OptionCreateOneWithoutValuesInput {
  create?: OptionCreateWithoutValuesInput;
  connect?: OptionWhereUniqueInput;
}

export interface AttributeCreateWithoutProductsInput {
  key: String;
  value: String;
}

export interface VariantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VariantWhereInput;
  AND?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  OR?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
  NOT?: VariantSubscriptionWhereInput[] | VariantSubscriptionWhereInput;
}

export interface BrandUpdateInput {
  name?: String;
  products?: ProductUpdateManyWithoutBrandInput;
}

export interface BrandWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: BrandWhereInput[] | BrandWhereInput;
  OR?: BrandWhereInput[] | BrandWhereInput;
  NOT?: BrandWhereInput[] | BrandWhereInput;
}

export interface ProductUpdateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    | ProductUpdateWithWhereUniqueWithoutBrandInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    | ProductUpsertWithWhereUniqueWithoutBrandInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateInput {
  name?: String;
  brand?: BrandUpdateOneRequiredWithoutProductsInput;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export interface ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutBrandDataInput;
}

export interface OptionValueUpdateWithoutOptionDataInput {
  name?: String;
}

export interface ProductUpdateWithoutBrandDataInput {
  name?: String;
  variants?: VariantUpdateManyInput;
  collections?: CollectionUpdateManyWithoutProductsInput;
  attributes?: AttributeUpdateManyWithoutProductsInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AttributeUpdateManyWithoutProductsInput {
  create?:
    | AttributeCreateWithoutProductsInput[]
    | AttributeCreateWithoutProductsInput;
  delete?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  connect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  disconnect?: AttributeWhereUniqueInput[] | AttributeWhereUniqueInput;
  update?:
    | AttributeUpdateWithWhereUniqueWithoutProductsInput[]
    | AttributeUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | AttributeUpsertWithWhereUniqueWithoutProductsInput[]
    | AttributeUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  updateMany?:
    | AttributeUpdateManyWithWhereNestedInput[]
    | AttributeUpdateManyWithWhereNestedInput;
}

export interface OptionValueCreateManyInput {
  create?: OptionValueCreateInput[] | OptionValueCreateInput;
  connect?: OptionValueWhereUniqueInput[] | OptionValueWhereUniqueInput;
}

export interface AttributeUpdateWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  data: AttributeUpdateWithoutProductsDataInput;
}

export interface OptionValueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OptionValueWhereInput;
  AND?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
  OR?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
  NOT?: OptionValueSubscriptionWhereInput[] | OptionValueSubscriptionWhereInput;
}

export interface AttributeUpdateWithoutProductsDataInput {
  key?: String;
  value?: String;
}

export interface OptionValueUpdateInput {
  name?: String;
  option?: OptionUpdateOneRequiredWithoutValuesInput;
}

export interface AttributeUpdateManyDataInput {
  key?: String;
  value?: String;
}

export interface AttributeUpdateManyWithWhereNestedInput {
  where: AttributeScalarWhereInput;
  data: AttributeUpdateManyDataInput;
}

export interface AttributeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  OR?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
  NOT?: AttributeScalarWhereInput[] | AttributeScalarWhereInput;
}

export interface AttributeUpsertWithWhereUniqueWithoutProductsInput {
  where: AttributeWhereUniqueInput;
  update: AttributeUpdateWithoutProductsDataInput;
  create: AttributeCreateWithoutProductsInput;
}

export type OptionValueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VariantUpdateInput {
  optionValues?: OptionValueUpdateManyInput;
  price?: Int;
}

export interface CollectionCreateManyWithoutProductsInput {
  create?:
    | CollectionCreateWithoutProductsInput[]
    | CollectionCreateWithoutProductsInput;
  connect?: CollectionWhereUniqueInput[] | CollectionWhereUniqueInput;
}

export interface BrandCreateOneWithoutProductsInput {
  create?: BrandCreateWithoutProductsInput;
  connect?: BrandWhereUniqueInput;
}

export type VariantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface VariantPreviousValues {
  id: ID_Output;
  price?: Int;
}

export interface VariantPreviousValuesPromise
  extends Promise<VariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
}

export interface VariantPreviousValuesSubscription
  extends Promise<AsyncIterator<VariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface AggregateAttribute {
  count: Int;
}

export interface AggregateAttributePromise
  extends Promise<AggregateAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributeSubscription
  extends Promise<AsyncIterator<AggregateAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttributeEdge {
  node: Attribute;
  cursor: String;
}

export interface AttributeEdgePromise
  extends Promise<AttributeEdge>,
    Fragmentable {
  node: <T = AttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributeEdgeSubscription
  extends Promise<AsyncIterator<AttributeEdge>>,
    Fragmentable {
  node: <T = AttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface VariantSubscriptionPayload {
  mutation: MutationType;
  node: Variant;
  updatedFields: String[];
  previousValues: VariantPreviousValues;
}

export interface VariantSubscriptionPayloadPromise
  extends Promise<VariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VariantPreviousValuesPromise>() => T;
}

export interface VariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VariantPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface VariantEdge {
  node: Variant;
  cursor: String;
}

export interface VariantEdgePromise extends Promise<VariantEdge>, Fragmentable {
  node: <T = VariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VariantEdgeSubscription
  extends Promise<AsyncIterator<VariantEdge>>,
    Fragmentable {
  node: <T = VariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Attribute {
  id: ID_Output;
  key: String;
  value: String;
}

export interface AttributePromise extends Promise<Attribute>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AttributeSubscription
  extends Promise<AsyncIterator<Attribute>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface AttributeSubscriptionPayload {
  mutation: MutationType;
  node: Attribute;
  updatedFields: String[];
  previousValues: AttributePreviousValues;
}

export interface AttributeSubscriptionPayloadPromise
  extends Promise<AttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributePreviousValuesPromise>() => T;
}

export interface AttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributePreviousValuesSubscription>() => T;
}

export interface OptionValueEdge {
  node: OptionValue;
  cursor: String;
}

export interface OptionValueEdgePromise
  extends Promise<OptionValueEdge>,
    Fragmentable {
  node: <T = OptionValuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionValueEdgeSubscription
  extends Promise<AsyncIterator<OptionValueEdge>>,
    Fragmentable {
  node: <T = OptionValueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttributePreviousValues {
  id: ID_Output;
  key: String;
  value: String;
}

export interface AttributePreviousValuesPromise
  extends Promise<AttributePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface AttributePreviousValuesSubscription
  extends Promise<AsyncIterator<AttributePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOption {
  count: Int;
}

export interface AggregateOptionPromise
  extends Promise<AggregateOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionSubscription
  extends Promise<AsyncIterator<AggregateOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttributeConnection {
  pageInfo: PageInfo;
  edges: AttributeEdge[];
}

export interface AttributeConnectionPromise
  extends Promise<AttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributeEdge>>() => T;
  aggregate: <T = AggregateAttributePromise>() => T;
}

export interface AttributeConnectionSubscription
  extends Promise<AsyncIterator<AttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributeSubscription>() => T;
}

export interface OptionConnection {
  pageInfo: PageInfo;
  edges: OptionEdge[];
}

export interface OptionConnectionPromise
  extends Promise<OptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionEdge>>() => T;
  aggregate: <T = AggregateOptionPromise>() => T;
}

export interface OptionConnectionSubscription
  extends Promise<AsyncIterator<OptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionSubscription>() => T;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface AggregateCollection {
  count: Int;
}

export interface AggregateCollectionPromise
  extends Promise<AggregateCollection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollectionSubscription
  extends Promise<AsyncIterator<AggregateCollection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CollectionConnection {
  pageInfo: PageInfo;
  edges: CollectionEdge[];
}

export interface CollectionConnectionPromise
  extends Promise<CollectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollectionEdge>>() => T;
  aggregate: <T = AggregateCollectionPromise>() => T;
}

export interface CollectionConnectionSubscription
  extends Promise<AsyncIterator<CollectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CollectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCollectionSubscription>() => T;
}

export interface Collection {
  id: ID_Output;
  name: String;
}

export interface CollectionPromise extends Promise<Collection>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CollectionSubscription
  extends Promise<AsyncIterator<Collection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollectionSubscriptionPayload {
  mutation: MutationType;
  node: Collection;
  updatedFields: String[];
  previousValues: CollectionPreviousValues;
}

export interface CollectionSubscriptionPayloadPromise
  extends Promise<CollectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollectionPreviousValuesPromise>() => T;
}

export interface CollectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollectionPreviousValuesSubscription>() => T;
}

export interface AggregateVariant {
  count: Int;
}

export interface AggregateVariantPromise
  extends Promise<AggregateVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVariantSubscription
  extends Promise<AsyncIterator<AggregateVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollectionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CollectionPreviousValuesPromise
  extends Promise<CollectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CollectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CollectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Option {
  id: ID_Output;
  name: String;
}

export interface OptionPromise extends Promise<Option>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  values: <T = FragmentableArray<OptionValue>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OptionSubscription
  extends Promise<AsyncIterator<Option>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  values: <T = Promise<AsyncIterator<OptionValueSubscription>>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OptionValueConnection {
  pageInfo: PageInfo;
  edges: OptionValueEdge[];
}

export interface OptionValueConnectionPromise
  extends Promise<OptionValueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptionValueEdge>>() => T;
  aggregate: <T = AggregateOptionValuePromise>() => T;
}

export interface OptionValueConnectionSubscription
  extends Promise<AsyncIterator<OptionValueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptionValueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptionValueSubscription>() => T;
}

export interface OptionSubscriptionPayload {
  mutation: MutationType;
  node: Option;
  updatedFields: String[];
  previousValues: OptionPreviousValues;
}

export interface OptionSubscriptionPayloadPromise
  extends Promise<OptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionPreviousValuesPromise>() => T;
}

export interface OptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionPreviousValuesSubscription>() => T;
}

export interface Brand {
  id: ID_Output;
  name: String;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OptionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface OptionPreviousValuesPromise
  extends Promise<OptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionPreviousValuesSubscription
  extends Promise<AsyncIterator<OptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VariantConnection {
  pageInfo: PageInfo;
  edges: VariantEdge[];
}

export interface VariantConnectionPromise
  extends Promise<VariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VariantEdge>>() => T;
  aggregate: <T = AggregateVariantPromise>() => T;
}

export interface VariantConnectionSubscription
  extends Promise<AsyncIterator<VariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVariantSubscription>() => T;
}

export interface Variant {
  id: ID_Output;
  price?: Int;
}

export interface VariantPromise extends Promise<Variant>, Fragmentable {
  id: () => Promise<ID_Output>;
  optionValues: <T = FragmentableArray<OptionValue>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  price: () => Promise<Int>;
}

export interface VariantSubscription
  extends Promise<AsyncIterator<Variant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  optionValues: <T = Promise<AsyncIterator<OptionValueSubscription>>>(
    args?: {
      where?: OptionValueWhereInput;
      orderBy?: OptionValueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  price: () => Promise<AsyncIterator<Int>>;
}

export interface OptionValuePreviousValues {
  id: ID_Output;
  name: String;
}

export interface OptionValuePreviousValuesPromise
  extends Promise<OptionValuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OptionValuePreviousValuesSubscription
  extends Promise<AsyncIterator<OptionValuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OptionValueSubscriptionPayload {
  mutation: MutationType;
  node: OptionValue;
  updatedFields: String[];
  previousValues: OptionValuePreviousValues;
}

export interface OptionValueSubscriptionPayloadPromise
  extends Promise<OptionValueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptionValuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptionValuePreviousValuesPromise>() => T;
}

export interface OptionValueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptionValueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptionValueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptionValuePreviousValuesSubscription>() => T;
}

export interface OptionValue {
  id: ID_Output;
  name: String;
}

export interface OptionValuePromise extends Promise<OptionValue>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  option: <T = OptionPromise>() => T;
}

export interface OptionValueSubscription
  extends Promise<AsyncIterator<OptionValue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  option: <T = OptionSubscription>() => T;
}

export interface AggregateOptionValue {
  count: Int;
}

export interface AggregateOptionValuePromise
  extends Promise<AggregateOptionValue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptionValueSubscription
  extends Promise<AsyncIterator<AggregateOptionValue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  variants: <T = FragmentableArray<Variant>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  collections: <T = FragmentableArray<Collection>>(
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attributes: <T = FragmentableArray<Attribute>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: <T = BrandSubscription>() => T;
  variants: <T = Promise<AsyncIterator<VariantSubscription>>>(
    args?: {
      where?: VariantWhereInput;
      orderBy?: VariantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  collections: <T = Promise<AsyncIterator<CollectionSubscription>>>(
    args?: {
      where?: CollectionWhereInput;
      orderBy?: CollectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  attributes: <T = Promise<AsyncIterator<AttributeSubscription>>>(
    args?: {
      where?: AttributeWhereInput;
      orderBy?: AttributeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CollectionEdge {
  node: Collection;
  cursor: String;
}

export interface CollectionEdgePromise
  extends Promise<CollectionEdge>,
    Fragmentable {
  node: <T = CollectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollectionEdgeSubscription
  extends Promise<AsyncIterator<CollectionEdge>>,
    Fragmentable {
  node: <T = CollectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OptionEdge {
  node: Option;
  cursor: String;
}

export interface OptionEdgePromise extends Promise<OptionEdge>, Fragmentable {
  node: <T = OptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptionEdgeSubscription
  extends Promise<AsyncIterator<OptionEdge>>,
    Fragmentable {
  node: <T = OptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Attribute",
    embedded: false
  },
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Collection",
    embedded: false
  },
  {
    name: "Option",
    embedded: false
  },
  {
    name: "OptionValue",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Variant",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
