/**
 * This file is automatically generated by GraphQL Nexus
 * Do not make changes to this file directly
 * 
 * For better typings, you should provide configuration for how to lookup 
 * the types. See the documentation for "typegenAutoConfig"
 */
import * as ctx from "../context"
import * as prisma from "./prisma-client/index"

declare global {
  interface GraphQLNexusGen extends GraphQLNexusGenTypes {}
}

// Maybe Promise
type MaybePromise<T> = T | PromiseLike<T>;

// Maybe Promise List
type MaybePromiseList<T> = Array<MaybePromise<T>>;

// Maybe Thunk
type MaybeThunk<T> = T | (() => T);

// Maybe Thunk, with args
type MaybeThunkArgs<T, A> = T | ((args?: A) => T);

export type QueryBrandsReturnType = BrandConnection_ReturnType;

export interface QueryBrandsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: BrandOrderByInput;
  skip?: number;
  where?: BrandWhereInput;
}

export type QueryCollectionReturnType = Collection_ReturnType;

export interface QueryCollectionArgs {
  collectionId: string;
}

export type QueryOptionsReturnType = OptionConnection_ReturnType;

export interface QueryOptionsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: OptionOrderByInput;
  skip?: number;
  where?: OptionWhereInput;
}

export type QueryProductsReturnType = ProductConnection_ReturnType;

export interface QueryProductsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: ProductOrderByInput;
  skip?: number;
  where?: ProductWhereInput;
}

export type QueryRootType = {};

export type Query_ReturnType = {};

export type BrandOrderByInput = "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

interface BrandWhereInput {
  AND: BrandWhereInput[];
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  name?: string;
  name_contains?: string;
  name_ends_with?: string;
  name_gt?: string;
  name_gte?: string;
  name_in: string[];
  name_lt?: string;
  name_lte?: string;
  name_not?: string;
  name_not_contains?: string;
  name_not_ends_with?: string;
  name_not_in: string[];
  name_not_starts_with?: string;
  name_starts_with?: string;
  NOT: BrandWhereInput[];
  OR: BrandWhereInput[];
  products_every?: ProductWhereInput;
  products_none?: ProductWhereInput;
  products_some?: ProductWhereInput;
}

interface ProductWhereInput {
  AND: ProductWhereInput[];
  attributes_every?: AttributeWhereInput;
  attributes_none?: AttributeWhereInput;
  attributes_some?: AttributeWhereInput;
  brand?: BrandWhereInput;
  collections_every?: CollectionWhereInput;
  collections_none?: CollectionWhereInput;
  collections_some?: CollectionWhereInput;
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  name?: string;
  name_contains?: string;
  name_ends_with?: string;
  name_gt?: string;
  name_gte?: string;
  name_in: string[];
  name_lt?: string;
  name_lte?: string;
  name_not?: string;
  name_not_contains?: string;
  name_not_ends_with?: string;
  name_not_in: string[];
  name_not_starts_with?: string;
  name_starts_with?: string;
  NOT: ProductWhereInput[];
  OR: ProductWhereInput[];
  variants_every?: VariantWhereInput;
  variants_none?: VariantWhereInput;
  variants_some?: VariantWhereInput;
}

interface AttributeWhereInput {
  AND: AttributeWhereInput[];
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  key?: string;
  key_contains?: string;
  key_ends_with?: string;
  key_gt?: string;
  key_gte?: string;
  key_in: string[];
  key_lt?: string;
  key_lte?: string;
  key_not?: string;
  key_not_contains?: string;
  key_not_ends_with?: string;
  key_not_in: string[];
  key_not_starts_with?: string;
  key_starts_with?: string;
  NOT: AttributeWhereInput[];
  OR: AttributeWhereInput[];
  products_every?: ProductWhereInput;
  products_none?: ProductWhereInput;
  products_some?: ProductWhereInput;
  value?: string;
  value_contains?: string;
  value_ends_with?: string;
  value_gt?: string;
  value_gte?: string;
  value_in: string[];
  value_lt?: string;
  value_lte?: string;
  value_not?: string;
  value_not_contains?: string;
  value_not_ends_with?: string;
  value_not_in: string[];
  value_not_starts_with?: string;
  value_starts_with?: string;
}

interface CollectionWhereInput {
  AND: CollectionWhereInput[];
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  name?: string;
  name_contains?: string;
  name_ends_with?: string;
  name_gt?: string;
  name_gte?: string;
  name_in: string[];
  name_lt?: string;
  name_lte?: string;
  name_not?: string;
  name_not_contains?: string;
  name_not_ends_with?: string;
  name_not_in: string[];
  name_not_starts_with?: string;
  name_starts_with?: string;
  NOT: CollectionWhereInput[];
  OR: CollectionWhereInput[];
  products_every?: ProductWhereInput;
  products_none?: ProductWhereInput;
  products_some?: ProductWhereInput;
}

interface VariantWhereInput {
  AND: VariantWhereInput[];
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  NOT: VariantWhereInput[];
  optionValues_every?: OptionValueWhereInput;
  optionValues_none?: OptionValueWhereInput;
  optionValues_some?: OptionValueWhereInput;
  OR: VariantWhereInput[];
  price?: number;
  price_gt?: number;
  price_gte?: number;
  price_in: number[];
  price_lt?: number;
  price_lte?: number;
  price_not?: number;
  price_not_in: number[];
}

interface OptionValueWhereInput {
  AND: OptionValueWhereInput[];
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  name?: string;
  name_contains?: string;
  name_ends_with?: string;
  name_gt?: string;
  name_gte?: string;
  name_in: string[];
  name_lt?: string;
  name_lte?: string;
  name_not?: string;
  name_not_contains?: string;
  name_not_ends_with?: string;
  name_not_in: string[];
  name_not_starts_with?: string;
  name_starts_with?: string;
  NOT: OptionValueWhereInput[];
  option?: OptionWhereInput;
  OR: OptionValueWhereInput[];
}

interface OptionWhereInput {
  AND: OptionWhereInput[];
  id?: string;
  id_contains?: string;
  id_ends_with?: string;
  id_gt?: string;
  id_gte?: string;
  id_in: string[];
  id_lt?: string;
  id_lte?: string;
  id_not?: string;
  id_not_contains?: string;
  id_not_ends_with?: string;
  id_not_in: string[];
  id_not_starts_with?: string;
  id_starts_with?: string;
  name?: string;
  name_contains?: string;
  name_ends_with?: string;
  name_gt?: string;
  name_gte?: string;
  name_in: string[];
  name_lt?: string;
  name_lte?: string;
  name_not?: string;
  name_not_contains?: string;
  name_not_ends_with?: string;
  name_not_in: string[];
  name_not_starts_with?: string;
  name_starts_with?: string;
  NOT: OptionWhereInput[];
  OR: OptionWhereInput[];
  values_every?: OptionValueWhereInput;
  values_none?: OptionValueWhereInput;
  values_some?: OptionValueWhereInput;
}

export type BrandConnectionEdgesReturnType = MaybePromiseList<BrandEdge_ReturnType>;

export type BrandConnectionPageInfoReturnType = PageInfo_ReturnType;

export type BrandConnectionRootType = prisma.BrandConnection;

export type BrandConnection_ReturnType = prisma.BrandConnection

export type BrandEdgeCursorReturnType = string;

export type BrandEdgeNodeReturnType = Brand_ReturnType;

export type BrandEdgeRootType = prisma.BrandEdge;

export type BrandEdge_ReturnType = prisma.BrandEdge

export type BrandIdReturnType = string;

export type BrandNameReturnType = string;

export type BrandProductsReturnType = MaybePromiseList<Product_ReturnType>;

export interface BrandProductsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: ProductOrderByInput;
  skip?: number;
  where?: ProductWhereInput;
}

export type BrandRootType = prisma.Brand;

export type Brand_ReturnType = prisma.Brand

export type ProductOrderByInput = "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

export type ProductBrandReturnType = Brand_ReturnType;

export type ProductIdReturnType = string;

export type ProductNameReturnType = string;

export type ProductOptionsReturnType = MaybePromiseList<Option_ReturnType>;

export type ProductVariantsReturnType = MaybePromiseList<Variant_ReturnType>;

export interface ProductVariantsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: VariantOrderByInput;
  skip?: number;
  where?: VariantWhereInput;
}

export type ProductRootType = prisma.Product;

export type Product_ReturnType = prisma.Product

export type OptionIdReturnType = string;

export type OptionNameReturnType = string;

export type OptionValuesReturnType = MaybePromiseList<OptionValue_ReturnType>;

export interface OptionValuesArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: OptionValueOrderByInput;
  skip?: number;
  where?: OptionValueWhereInput;
}

export type OptionRootType = prisma.Option;

export type Option_ReturnType = prisma.Option

export type OptionValueOrderByInput = "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

export type OptionValueIdReturnType = string;

export type OptionValueNameReturnType = string;

export type OptionValueOptionReturnType = Option_ReturnType;

export type OptionValueRootType = prisma.OptionValue;

export type OptionValue_ReturnType = prisma.OptionValue

export type VariantOrderByInput = "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "price_ASC" | "price_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

export type VariantIdReturnType = string;

export type VariantOptionValuesReturnType = MaybePromiseList<OptionValue_ReturnType>;

export interface VariantOptionValuesArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: OptionValueOrderByInput;
  skip?: number;
  where?: OptionValueWhereInput;
}

export type VariantPriceReturnType = null | number;

export type VariantRootType = prisma.Variant;

export type Variant_ReturnType = prisma.Variant

export type PageInfoEndCursorReturnType = null | string;

export type PageInfoHasNextPageReturnType = boolean;

export type PageInfoHasPreviousPageReturnType = boolean;

export type PageInfoStartCursorReturnType = null | string;

export type PageInfoRootType = prisma.PageInfo;

export type PageInfo_ReturnType = prisma.PageInfo

export type CollectionAttributesReturnType = MaybePromiseList<Attribute_ReturnType>;

export type CollectionBrandsReturnType = MaybePromiseList<Brand_ReturnType>;

export type CollectionIdReturnType = string;

export type CollectionNameReturnType = string;

export type CollectionOptionsReturnType = MaybePromiseList<Option_ReturnType>;

export type CollectionProductsReturnType = MaybePromiseList<Product_ReturnType>;

export interface CollectionProductsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: ProductOrderByInput;
  skip?: number;
  where?: ProductWhereInput;
}

export type CollectionRootType = prisma.Collection;

export type Collection_ReturnType = prisma.Collection

export type AttributeIdReturnType = string;

export type AttributeKeyReturnType = string;

export type AttributeProductsReturnType = MaybePromiseList<Product_ReturnType>;

export interface AttributeProductsArgs {
  after?: string;
  before?: string;
  first?: number;
  last?: number;
  orderBy?: ProductOrderByInput;
  skip?: number;
  where?: ProductWhereInput;
}

export type AttributeValueReturnType = string;

export type AttributeRootType = prisma.Attribute;

export type Attribute_ReturnType = prisma.Attribute

export type OptionOrderByInput = "createdAt_ASC" | "createdAt_DESC" | "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC" | "updatedAt_ASC" | "updatedAt_DESC";

export type OptionConnectionEdgesReturnType = MaybePromiseList<OptionEdge_ReturnType>;

export type OptionConnectionPageInfoReturnType = PageInfo_ReturnType;

export type OptionConnectionRootType = prisma.OptionConnection;

export type OptionConnection_ReturnType = prisma.OptionConnection

export type OptionEdgeCursorReturnType = string;

export type OptionEdgeNodeReturnType = Option_ReturnType;

export type OptionEdgeRootType = prisma.OptionEdge;

export type OptionEdge_ReturnType = prisma.OptionEdge

export type ProductConnectionEdgesReturnType = MaybePromiseList<ProductEdge_ReturnType>;

export type ProductConnectionPageInfoReturnType = PageInfo_ReturnType;

export type ProductConnectionRootType = prisma.ProductConnection;

export type ProductConnection_ReturnType = prisma.ProductConnection

export type ProductEdgeCursorReturnType = string;

export type ProductEdgeNodeReturnType = Product_ReturnType;

export type ProductEdgeRootType = prisma.ProductEdge;

export type ProductEdge_ReturnType = prisma.ProductEdge

export type MutationAddProductsToCollectionReturnType = Collection_ReturnType;

export interface MutationAddProductsToCollectionArgs {
  collectionId: string;
  productIds: string[];
}

export type MutationCreateProductReturnType = Product_ReturnType;

export interface MutationCreateProductArgs {
  data: CreateProductInput;
}

export type MutationRemoveProductsFromCollectionReturnType = Collection_ReturnType;

export interface MutationRemoveProductsFromCollectionArgs {
  collectionId: string;
  productIds: string[];
}

export type MutationUpdateProductReturnType = Product_ReturnType;

export interface MutationUpdateProductArgs {
  data: UpdateProductInput;
}

export type MutationRootType = {};

export type Mutation_ReturnType = {};

interface CreateProductInput {
  attributesIds: UniqueInput[];
  brand: UniqueInput;
  name: string;
  variants: CreateVariantInput[];
}

interface UniqueInput {
  id: string;
}

interface CreateVariantInput {
  availableForSale: boolean;
  optionsValueIds: UniqueInput[];
  price: number;
}

interface UpdateProductInput {
  attributesIds: UniqueInput[];
  brand: UniqueInput;
  id: string;
  name: string;
  variants: UpdateVariantInput[];
}

interface UpdateVariantInput {
  availableForSale: boolean;
  id: string;
  optionsValueIds: UniqueInput[];
  price: number;
}

export interface GraphQLNexusGenArgTypes {
  Query: {
    brands: QueryBrandsArgs;
    collection: QueryCollectionArgs;
    options: QueryOptionsArgs;
    products: QueryProductsArgs;
  };
  Brand: {
    products: BrandProductsArgs;
  };
  Product: {
    variants: ProductVariantsArgs;
  };
  Option: {
    values: OptionValuesArgs;
  };
  Variant: {
    optionValues: VariantOptionValuesArgs;
  };
  Collection: {
    products: CollectionProductsArgs;
  };
  Attribute: {
    products: AttributeProductsArgs;
  };
  Mutation: {
    addProductsToCollection: MutationAddProductsToCollectionArgs;
    createProduct: MutationCreateProductArgs;
    removeProductsFromCollection: MutationRemoveProductsFromCollectionArgs;
    updateProduct: MutationUpdateProductArgs;
  };
}

export interface GraphQLNexusGenRootTypes {
  Query: QueryRootType;
  BrandConnection: BrandConnectionRootType;
  BrandEdge: BrandEdgeRootType;
  Brand: BrandRootType;
  Product: ProductRootType;
  Option: OptionRootType;
  OptionValue: OptionValueRootType;
  Variant: VariantRootType;
  PageInfo: PageInfoRootType;
  Collection: CollectionRootType;
  Attribute: AttributeRootType;
  OptionConnection: OptionConnectionRootType;
  OptionEdge: OptionEdgeRootType;
  ProductConnection: ProductConnectionRootType;
  ProductEdge: ProductEdgeRootType;
  Mutation: MutationRootType;
}

export interface GraphQLNexusGenReturnTypes {
  Query: {
    brands: QueryBrandsReturnType;
    collection: QueryCollectionReturnType;
    options: QueryOptionsReturnType;
    products: QueryProductsReturnType;
  };
  BrandConnection: {
    edges: BrandConnectionEdgesReturnType;
    pageInfo: BrandConnectionPageInfoReturnType;
  };
  BrandEdge: {
    cursor: BrandEdgeCursorReturnType;
    node: BrandEdgeNodeReturnType;
  };
  Brand: {
    id: BrandIdReturnType;
    name: BrandNameReturnType;
    products: BrandProductsReturnType;
  };
  Product: {
    brand: ProductBrandReturnType;
    id: ProductIdReturnType;
    name: ProductNameReturnType;
    options: ProductOptionsReturnType;
    variants: ProductVariantsReturnType;
  };
  Option: {
    id: OptionIdReturnType;
    name: OptionNameReturnType;
    values: OptionValuesReturnType;
  };
  OptionValue: {
    id: OptionValueIdReturnType;
    name: OptionValueNameReturnType;
    option: OptionValueOptionReturnType;
  };
  Variant: {
    id: VariantIdReturnType;
    optionValues: VariantOptionValuesReturnType;
    price: VariantPriceReturnType;
  };
  PageInfo: {
    endCursor: PageInfoEndCursorReturnType;
    hasNextPage: PageInfoHasNextPageReturnType;
    hasPreviousPage: PageInfoHasPreviousPageReturnType;
    startCursor: PageInfoStartCursorReturnType;
  };
  Collection: {
    attributes: CollectionAttributesReturnType;
    brands: CollectionBrandsReturnType;
    id: CollectionIdReturnType;
    name: CollectionNameReturnType;
    options: CollectionOptionsReturnType;
    products: CollectionProductsReturnType;
  };
  Attribute: {
    id: AttributeIdReturnType;
    key: AttributeKeyReturnType;
    products: AttributeProductsReturnType;
    value: AttributeValueReturnType;
  };
  OptionConnection: {
    edges: OptionConnectionEdgesReturnType;
    pageInfo: OptionConnectionPageInfoReturnType;
  };
  OptionEdge: {
    cursor: OptionEdgeCursorReturnType;
    node: OptionEdgeNodeReturnType;
  };
  ProductConnection: {
    edges: ProductConnectionEdgesReturnType;
    pageInfo: ProductConnectionPageInfoReturnType;
  };
  ProductEdge: {
    cursor: ProductEdgeCursorReturnType;
    node: ProductEdgeNodeReturnType;
  };
  Mutation: {
    addProductsToCollection: MutationAddProductsToCollectionReturnType;
    createProduct: MutationCreateProductReturnType;
    removeProductsFromCollection: MutationRemoveProductsFromCollectionReturnType;
    updateProduct: MutationUpdateProductReturnType;
  };
}

export interface GraphQLNexusGenTypes {
  argTypes: GraphQLNexusGenArgTypes;
  backingTypes: GraphQLNexusGenRootTypes;
  returnTypes: GraphQLNexusGenReturnTypes;
  context: ctx.Context;
  enums: {
    BrandOrderByInput: BrandOrderByInput;
    ProductOrderByInput: ProductOrderByInput;
    OptionValueOrderByInput: OptionValueOrderByInput;
    VariantOrderByInput: VariantOrderByInput;
    OptionOrderByInput: OptionOrderByInput;
  };
  objects: {
    Query: QueryRootType;
    BrandConnection: BrandConnectionRootType;
    BrandEdge: BrandEdgeRootType;
    Brand: BrandRootType;
    Product: ProductRootType;
    Option: OptionRootType;
    OptionValue: OptionValueRootType;
    Variant: VariantRootType;
    PageInfo: PageInfoRootType;
    Collection: CollectionRootType;
    Attribute: AttributeRootType;
    OptionConnection: OptionConnectionRootType;
    OptionEdge: OptionEdgeRootType;
    ProductConnection: ProductConnectionRootType;
    ProductEdge: ProductEdgeRootType;
    Mutation: MutationRootType;
  };
  interfaces: {};
  unions: {};
  scalars: {
    String: any;
    Int: any;
    ID: any;
    Boolean: any;
  };
  inputObjects: {
    BrandWhereInput: any;
    ProductWhereInput: any;
    AttributeWhereInput: any;
    CollectionWhereInput: any;
    VariantWhereInput: any;
    OptionValueWhereInput: any;
    OptionWhereInput: any;
    CreateProductInput: any;
    UniqueInput: any;
    CreateVariantInput: any;
    UpdateProductInput: any;
    UpdateVariantInput: any;
  };
  allInputTypes: 
    | Extract<keyof GraphQLNexusGenTypes['inputObjects'], string>
    | Extract<keyof GraphQLNexusGenTypes['enums'], string>
    | Extract<keyof GraphQLNexusGenTypes['scalars'], string>;
  allOutputTypes: 
    | Extract<keyof GraphQLNexusGenTypes['objects'], string>
    | Extract<keyof GraphQLNexusGenTypes['enums'], string>
    | Extract<keyof GraphQLNexusGenTypes['unions'], string>
    | Extract<keyof GraphQLNexusGenTypes['interfaces'], string>
    | Extract<keyof GraphQLNexusGenTypes['scalars'], string>;
}

export type Gen = GraphQLNexusGenTypes;
